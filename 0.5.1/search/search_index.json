{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Headlamp is an easy-to-use and extensible Kubernetes web UI. Headlamp was created to be a Kubernetes web UI that has the traditional functionality of other web UIs/dashboards available (i.e. to list and view resources) as well as other features. Headlamp can be used in-cluster , where it's accessed through a web browser, or as a desktop application (using the information defined in the user's kubeconfig). Get involved Check out our contributing section and join the discussion on the #headlamp channel in the Kubernetes Slack.","title":"Introduction"},{"location":"#get-involved","text":"Check out our contributing section and join the discussion on the #headlamp channel in the Kubernetes Slack.","title":"Get involved"},{"location":"_index/","text":"Headlamp is an easy-to-use and extensible Kubernetes web UI. Headlamp was created to be a Kubernetes web UI that has the traditional functionality of other web UIs/dashboards available (i.e. to list and view resources) as well as other features. Headlamp can be used in-cluster , where it's accessed through a web browser, or as a desktop application (using the information defined in the user's kubeconfig). Get involved Check out our contributing section and join the discussion on the #headlamp channel in the Kubernetes Slack.","title":"Headlamp"},{"location":"_index/#get-involved","text":"Check out our contributing section and join the discussion on the #headlamp channel in the Kubernetes Slack.","title":"Get involved"},{"location":"contributing/","text":"This section has information on how to contribute to Headlamp. It assumes you have cloned this repository (or your own Github fork). Any contributions to the project are accepted under the terms of the project's license ( Apache 2.0 ). Code of Conduct Please refer to the Kinvolk Code of Conduct . Development practices The Headlamp project follows the Kinvolk Contribution Guidelines which promotes good and consistent contribution practises across Kinvolk's projects. Before start contributing, and in addition to this section, please read those guidelines. Filing an issue or feature request Please use the project's issue tracker for filing any bugs you find or features you think are useful. Translations If you want to contribute to the internationalization of Headlamp, please refer to the dedicated i18n docs . Complex contributions If you have a complex contribution in mind (meaning changes in the architecture or a lot of LOC changed), it is advisable to first file a Github issue and discuss the implementation with the project's maintainers. Coding style The coding style for backend and frontend should be consistent. For helping and verifying that, we have go and js linters. For linting the backend and frontend , use the following commands (respectively): make backend-lint make frontend-lint The linters are also run in the CI system, so any PRs you create will be tested for compliance with the coding style. To speed up a review from the project's maintainers, please make sure that the CI checks are passing for your PR. Commit guidelines For the general guidelines on making PRs/commits easier to review, please check out Kinvolk's contribution guidelines on git .","title":"Contribution Guidelines"},{"location":"contributing/#code-of-conduct","text":"Please refer to the Kinvolk Code of Conduct .","title":"Code of Conduct"},{"location":"contributing/#development-practices","text":"The Headlamp project follows the Kinvolk Contribution Guidelines which promotes good and consistent contribution practises across Kinvolk's projects. Before start contributing, and in addition to this section, please read those guidelines.","title":"Development practices"},{"location":"contributing/#filing-an-issue-or-feature-request","text":"Please use the project's issue tracker for filing any bugs you find or features you think are useful.","title":"Filing an issue or feature request"},{"location":"contributing/#translations","text":"If you want to contribute to the internationalization of Headlamp, please refer to the dedicated i18n docs .","title":"Translations"},{"location":"contributing/#complex-contributions","text":"If you have a complex contribution in mind (meaning changes in the architecture or a lot of LOC changed), it is advisable to first file a Github issue and discuss the implementation with the project's maintainers.","title":"Complex contributions"},{"location":"contributing/#coding-style","text":"The coding style for backend and frontend should be consistent. For helping and verifying that, we have go and js linters. For linting the backend and frontend , use the following commands (respectively): make backend-lint make frontend-lint The linters are also run in the CI system, so any PRs you create will be tested for compliance with the coding style. To speed up a review from the project's maintainers, please make sure that the CI checks are passing for your PR.","title":"Coding style"},{"location":"contributing/#commit-guidelines","text":"For the general guidelines on making PRs/commits easier to review, please check out Kinvolk's contribution guidelines on git .","title":"Commit guidelines"},{"location":"platforms/","text":"This section shows the different platforms where Headlamp has been tested (in-cluster) or is intended to be tested, and useful observations about it. If you have tested Headlamp on a different flavor or Kubernetes, please file a PR or issue to add your remarks to the list. The \"works\" column refers to the overall Kubernetes related functionality when running in the respective platform; it may have 3 different values: - \u2714\ufe0f : Has been tried and works fine to the extent of what has been tested - \u274c : Has been tried and didn't work or had issues that prevented a regular use of it - \u2754: Hasn't been tried/reported yet Platform Works Comments Amazon EKS \u2714\ufe0f - As reported DigitalOcean Kubernetes \u2754 - Have you tried Headlamp on this platform? Please report your experience. Google Kubernetes Engine (GKE) \u2754 - Have you tried Headlamp on this platform? Please report your experience. K3s \u2714\ufe0f - Simple to install / expose with the regular in-cluster instructions . Kind \u2714\ufe0f - Simple to install / expose with the regular in-cluster instructions . Lokomotive \u2714\ufe0f - Works with the regular in-cluster instructions - There's also the Lokomotive Web UI as a component, which is Microsoft AKS \u2714\ufe0f Testing (not suitable for production): - Deploy Headlamp from the in-cluster instructions - Enable the http_application_routing addon (this creates a DNS zone) - Use the DNS zone name as the domain for Headlamp, i.e. if it is 1234567.eastus.aksapp.io , then apply Headlamp's ingress using headlamp.1234567.eastus.aksapp.io as the path and use kubernetes.io/ingress.class: addon-http-application-routing as the ingress class annotation. For production, please follow the intructions to deploy with an HTTPS ingress controller . Minikube \u2714\ufe0f - For exposing with an ingress, enable ingresses with minikube addons enable ingress - There are docs about the development with Minikube.","title":"Tested Kubernetes Platforms"},{"location":"development/","text":"This is a quickstart guide for building and running Headlamp for development. Please make sure you read the Contribution Guidelines as well before starting to contribute to the project. Build the code Headlamp is composed by a backend and a frontend . You can build both the backend and frontend by running. make Or individually: make backend and make frontend Run the code The quickest way to get the backend and frontend running for development is the following (respectively): make run-backend and in a different terminal instance: make run-frontend Build the app You can build the app for Linux, Windows or Mac. Do so on the platform you are building for. That is build the mac app on a Mac, and the linux app on a linux box. First we need to make backend frontend Then choose the relevant command. make app-linux make app-windows make app-mac See the generated app files in app/dist/ Build a container image The following command builds a container image for Headlamp from the current source. It will run the frontend from a backend 's static server, and options can be appended to the main command as arguments. make image Running the container image With docker you can run the Headlamp image( ghcr.io/kinvolk/headlamp:latest ). Note, the mount arguments add folders that are referenced in the ~/.kube folders - you may need to add other folders if your config refers to more folders. docker run --network=\"host\" -p 127.0.0.1:4466:4466/tcp --mount type=bind,source=\"/home/rene/.minikube\",target=$HOME/.minikube --mount type=bind,source=\"$HOME/.kube\",target=/root/.kube ghcr.io/kinvolk/headlamp:latest /headlamp/server -html-static-dir /headlamp/frontend -plugins-dir=/headlamp/plugins If you want to make a new container image called kinvolk/headlamp:development you can run it like this: $ DOCKER_IMAGE_VERSION=development make image ... Successfully tagged kinvolk/headlamp:development $ docker run --network=\"host\" -p 127.0.0.1:4466:4466/tcp --mount type=bind,source=\"/home/rene/.minikube\",target=$HOME/.minikube --mount type=bind,source=\"$HOME/.kube\",target=/root/.kube kinvolk/headlamp:development /headlamp/server -html-static-dir /headlamp/frontend -plugins-dir=/headlamp/plugins Then go to https://localhost:4466 in your browser. Minikube \"in-cluster\" These instructions are for if you want to use Headlamp running \"in-cluster\", and test it locally on minikube with a local container image. We assume you've already setup a minikube (probably with minikube start --driver=docker ). Container image in the minikub docker environment First we have to make the container image in the minikube docker environment. This is needed because minikube looks for container images in there, not ones made in the local docker environment. $ eval $(minikube docker-env) $ DOCKER_IMAGE_VERSION=development make image Create a deployment yaml. $ kubectl create deployment headlamp -n kube-system --image=kinvolk/headlamp:development -o yaml --dry-run -- /headlamp/server -html-static-dir /headlamp/frontend -in-cluster -plugins-dir=/headlamp/plugins > minikube-headlamp.yaml To use the local container image we change the imagePullPolicy to Never. Making kubectl use local images - which is what you want in development. apiVersion: apps/v1 kind: Deployment metadata: creationTimestamp: null labels: app: headlamp name: headlamp namespace: kube-system spec: replicas: 1 selector: matchLabels: app: headlamp strategy: {} template: metadata: creationTimestamp: null labels: app: headlamp spec: containers: - command: - /headlamp/server - -html-static-dir - /headlamp/frontend - -in-cluster - -plugins-dir=/headlamp/plugins image: kinvolk/headlamp:development name: headlamp imagePullPolicy: Never resources: {} status: {} Now we create the deployment. $ kubectl apply -f minikube-headlamp.yaml Then we expose the deployment, and get a URL where we can see it. $ kubectl expose deployment headlamp -n kube-system --type=NodePort --port=4466 service/headlamp exposed $ kubectl get service headlamp -n kube-system NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE headlamp NodePort 10.99.144.210 <none> 4466:30712/TCP 6m57s $ minikube service headlamp -n kube-system --url http://192.168.49.2:30342 Go to the URL printed by minikube in your browser, and get your token to login. Shipping plugins in the Docker image Since the Headlamp server has an option ( -plugins-dir ) for indicating where to find any plugins, a deployment of Headlamp using the Docker image can mount a plugins folder and point to it by using the mentioned option. An alternative is to build an image that ships some plugins in it. For that, just create a \".plugins\" folder in the Headlamp project directory as the Dockerfile will include it and point to it by default.","title":"Development"},{"location":"development/#build-the-code","text":"Headlamp is composed by a backend and a frontend . You can build both the backend and frontend by running. make Or individually: make backend and make frontend","title":"Build the code"},{"location":"development/#run-the-code","text":"The quickest way to get the backend and frontend running for development is the following (respectively): make run-backend and in a different terminal instance: make run-frontend","title":"Run the code"},{"location":"development/#build-the-app","text":"You can build the app for Linux, Windows or Mac. Do so on the platform you are building for. That is build the mac app on a Mac, and the linux app on a linux box. First we need to make backend frontend Then choose the relevant command. make app-linux make app-windows make app-mac See the generated app files in app/dist/","title":"Build the app"},{"location":"development/#build-a-container-image","text":"The following command builds a container image for Headlamp from the current source. It will run the frontend from a backend 's static server, and options can be appended to the main command as arguments. make image","title":"Build a container image"},{"location":"development/#running-the-container-image","text":"With docker you can run the Headlamp image( ghcr.io/kinvolk/headlamp:latest ). Note, the mount arguments add folders that are referenced in the ~/.kube folders - you may need to add other folders if your config refers to more folders. docker run --network=\"host\" -p 127.0.0.1:4466:4466/tcp --mount type=bind,source=\"/home/rene/.minikube\",target=$HOME/.minikube --mount type=bind,source=\"$HOME/.kube\",target=/root/.kube ghcr.io/kinvolk/headlamp:latest /headlamp/server -html-static-dir /headlamp/frontend -plugins-dir=/headlamp/plugins If you want to make a new container image called kinvolk/headlamp:development you can run it like this: $ DOCKER_IMAGE_VERSION=development make image ... Successfully tagged kinvolk/headlamp:development $ docker run --network=\"host\" -p 127.0.0.1:4466:4466/tcp --mount type=bind,source=\"/home/rene/.minikube\",target=$HOME/.minikube --mount type=bind,source=\"$HOME/.kube\",target=/root/.kube kinvolk/headlamp:development /headlamp/server -html-static-dir /headlamp/frontend -plugins-dir=/headlamp/plugins Then go to https://localhost:4466 in your browser.","title":"Running the container image"},{"location":"development/#minikube-in-cluster","text":"These instructions are for if you want to use Headlamp running \"in-cluster\", and test it locally on minikube with a local container image. We assume you've already setup a minikube (probably with minikube start --driver=docker ).","title":"Minikube \"in-cluster\""},{"location":"development/#container-image-in-the-minikub-docker-environment","text":"First we have to make the container image in the minikube docker environment. This is needed because minikube looks for container images in there, not ones made in the local docker environment. $ eval $(minikube docker-env) $ DOCKER_IMAGE_VERSION=development make image","title":"Container image in the minikub docker environment"},{"location":"development/#create-a-deployment-yaml","text":"$ kubectl create deployment headlamp -n kube-system --image=kinvolk/headlamp:development -o yaml --dry-run -- /headlamp/server -html-static-dir /headlamp/frontend -in-cluster -plugins-dir=/headlamp/plugins > minikube-headlamp.yaml To use the local container image we change the imagePullPolicy to Never. Making kubectl use local images - which is what you want in development. apiVersion: apps/v1 kind: Deployment metadata: creationTimestamp: null labels: app: headlamp name: headlamp namespace: kube-system spec: replicas: 1 selector: matchLabels: app: headlamp strategy: {} template: metadata: creationTimestamp: null labels: app: headlamp spec: containers: - command: - /headlamp/server - -html-static-dir - /headlamp/frontend - -in-cluster - -plugins-dir=/headlamp/plugins image: kinvolk/headlamp:development name: headlamp imagePullPolicy: Never resources: {} status: {} Now we create the deployment. $ kubectl apply -f minikube-headlamp.yaml Then we expose the deployment, and get a URL where we can see it. $ kubectl expose deployment headlamp -n kube-system --type=NodePort --port=4466 service/headlamp exposed $ kubectl get service headlamp -n kube-system NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE headlamp NodePort 10.99.144.210 <none> 4466:30712/TCP 6m57s $ minikube service headlamp -n kube-system --url http://192.168.49.2:30342 Go to the URL printed by minikube in your browser, and get your token to login.","title":"Create a deployment yaml."},{"location":"development/#shipping-plugins-in-the-docker-image","text":"Since the Headlamp server has an option ( -plugins-dir ) for indicating where to find any plugins, a deployment of Headlamp using the Docker image can mount a plugins folder and point to it by using the mentioned option. An alternative is to build an image that ships some plugins in it. For that, just create a \".plugins\" folder in the Headlamp project directory as the Dockerfile will include it and point to it by default.","title":"Shipping plugins in the Docker image"},{"location":"development/_index/","text":"This is a quickstart guide for building and running Headlamp for development. Please make sure you read the Contribution Guidelines as well before starting to contribute to the project. Build the code Headlamp is composed by a backend and a frontend . You can build both the backend and frontend by running. make Or individually: make backend and make frontend Run the code The quickest way to get the backend and frontend running for development is the following (respectively): make run-backend and in a different terminal instance: make run-frontend Build the app You can build the app for Linux, Windows or Mac. Do so on the platform you are building for. That is build the mac app on a Mac, and the linux app on a linux box. First we need to make backend frontend Then choose the relevant command. make app-linux make app-windows make app-mac See the generated app files in app/dist/ Build a container image The following command builds a container image for Headlamp from the current source. It will run the frontend from a backend 's static server, and options can be appended to the main command as arguments. make image Running the container image With docker you can run the Headlamp image( ghcr.io/kinvolk/headlamp:latest ). Note, the mount arguments add folders that are referenced in the ~/.kube folders - you may need to add other folders if your config refers to more folders. docker run --network=\"host\" -p 127.0.0.1:4466:4466/tcp --mount type=bind,source=\"/home/rene/.minikube\",target=$HOME/.minikube --mount type=bind,source=\"$HOME/.kube\",target=/root/.kube ghcr.io/kinvolk/headlamp:latest /headlamp/server -html-static-dir /headlamp/frontend -plugins-dir=/headlamp/plugins If you want to make a new container image called kinvolk/headlamp:development you can run it like this: $ DOCKER_IMAGE_VERSION=development make image ... Successfully tagged kinvolk/headlamp:development $ docker run --network=\"host\" -p 127.0.0.1:4466:4466/tcp --mount type=bind,source=\"/home/rene/.minikube\",target=$HOME/.minikube --mount type=bind,source=\"$HOME/.kube\",target=/root/.kube kinvolk/headlamp:development /headlamp/server -html-static-dir /headlamp/frontend -plugins-dir=/headlamp/plugins Then go to https://localhost:4466 in your browser. Minikube \"in-cluster\" These instructions are for if you want to use Headlamp running \"in-cluster\", and test it locally on minikube with a local container image. We assume you've already setup a minikube (probably with minikube start --driver=docker ). Container image in the minikub docker environment First we have to make the container image in the minikube docker environment. This is needed because minikube looks for container images in there, not ones made in the local docker environment. $ eval $(minikube docker-env) $ DOCKER_IMAGE_VERSION=development make image Create a deployment yaml. $ kubectl create deployment headlamp -n kube-system --image=kinvolk/headlamp:development -o yaml --dry-run -- /headlamp/server -html-static-dir /headlamp/frontend -in-cluster -plugins-dir=/headlamp/plugins > minikube-headlamp.yaml To use the local container image we change the imagePullPolicy to Never. Making kubectl use local images - which is what you want in development. apiVersion: apps/v1 kind: Deployment metadata: creationTimestamp: null labels: app: headlamp name: headlamp namespace: kube-system spec: replicas: 1 selector: matchLabels: app: headlamp strategy: {} template: metadata: creationTimestamp: null labels: app: headlamp spec: containers: - command: - /headlamp/server - -html-static-dir - /headlamp/frontend - -in-cluster - -plugins-dir=/headlamp/plugins image: kinvolk/headlamp:development name: headlamp imagePullPolicy: Never resources: {} status: {} Now we create the deployment. $ kubectl apply -f minikube-headlamp.yaml Then we expose the deployment, and get a URL where we can see it. $ kubectl expose deployment headlamp -n kube-system --type=NodePort --port=4466 service/headlamp exposed $ kubectl get service headlamp -n kube-system NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE headlamp NodePort 10.99.144.210 <none> 4466:30712/TCP 6m57s $ minikube service headlamp -n kube-system --url http://192.168.49.2:30342 Go to the URL printed by minikube in your browser, and get your token to login. Shipping plugins in the Docker image Since the Headlamp server has an option ( -plugins-dir ) for indicating where to find any plugins, a deployment of Headlamp using the Docker image can mount a plugins folder and point to it by using the mentioned option. An alternative is to build an image that ships some plugins in it. For that, just create a \".plugins\" folder in the Headlamp project directory as the Dockerfile will include it and point to it by default.","title":"Development"},{"location":"development/_index/#build-the-code","text":"Headlamp is composed by a backend and a frontend . You can build both the backend and frontend by running. make Or individually: make backend and make frontend","title":"Build the code"},{"location":"development/_index/#run-the-code","text":"The quickest way to get the backend and frontend running for development is the following (respectively): make run-backend and in a different terminal instance: make run-frontend","title":"Run the code"},{"location":"development/_index/#build-the-app","text":"You can build the app for Linux, Windows or Mac. Do so on the platform you are building for. That is build the mac app on a Mac, and the linux app on a linux box. First we need to make backend frontend Then choose the relevant command. make app-linux make app-windows make app-mac See the generated app files in app/dist/","title":"Build the app"},{"location":"development/_index/#build-a-container-image","text":"The following command builds a container image for Headlamp from the current source. It will run the frontend from a backend 's static server, and options can be appended to the main command as arguments. make image","title":"Build a container image"},{"location":"development/_index/#running-the-container-image","text":"With docker you can run the Headlamp image( ghcr.io/kinvolk/headlamp:latest ). Note, the mount arguments add folders that are referenced in the ~/.kube folders - you may need to add other folders if your config refers to more folders. docker run --network=\"host\" -p 127.0.0.1:4466:4466/tcp --mount type=bind,source=\"/home/rene/.minikube\",target=$HOME/.minikube --mount type=bind,source=\"$HOME/.kube\",target=/root/.kube ghcr.io/kinvolk/headlamp:latest /headlamp/server -html-static-dir /headlamp/frontend -plugins-dir=/headlamp/plugins If you want to make a new container image called kinvolk/headlamp:development you can run it like this: $ DOCKER_IMAGE_VERSION=development make image ... Successfully tagged kinvolk/headlamp:development $ docker run --network=\"host\" -p 127.0.0.1:4466:4466/tcp --mount type=bind,source=\"/home/rene/.minikube\",target=$HOME/.minikube --mount type=bind,source=\"$HOME/.kube\",target=/root/.kube kinvolk/headlamp:development /headlamp/server -html-static-dir /headlamp/frontend -plugins-dir=/headlamp/plugins Then go to https://localhost:4466 in your browser.","title":"Running the container image"},{"location":"development/_index/#minikube-in-cluster","text":"These instructions are for if you want to use Headlamp running \"in-cluster\", and test it locally on minikube with a local container image. We assume you've already setup a minikube (probably with minikube start --driver=docker ).","title":"Minikube \"in-cluster\""},{"location":"development/_index/#container-image-in-the-minikub-docker-environment","text":"First we have to make the container image in the minikube docker environment. This is needed because minikube looks for container images in there, not ones made in the local docker environment. $ eval $(minikube docker-env) $ DOCKER_IMAGE_VERSION=development make image","title":"Container image in the minikub docker environment"},{"location":"development/_index/#create-a-deployment-yaml","text":"$ kubectl create deployment headlamp -n kube-system --image=kinvolk/headlamp:development -o yaml --dry-run -- /headlamp/server -html-static-dir /headlamp/frontend -in-cluster -plugins-dir=/headlamp/plugins > minikube-headlamp.yaml To use the local container image we change the imagePullPolicy to Never. Making kubectl use local images - which is what you want in development. apiVersion: apps/v1 kind: Deployment metadata: creationTimestamp: null labels: app: headlamp name: headlamp namespace: kube-system spec: replicas: 1 selector: matchLabels: app: headlamp strategy: {} template: metadata: creationTimestamp: null labels: app: headlamp spec: containers: - command: - /headlamp/server - -html-static-dir - /headlamp/frontend - -in-cluster - -plugins-dir=/headlamp/plugins image: kinvolk/headlamp:development name: headlamp imagePullPolicy: Never resources: {} status: {} Now we create the deployment. $ kubectl apply -f minikube-headlamp.yaml Then we expose the deployment, and get a URL where we can see it. $ kubectl expose deployment headlamp -n kube-system --type=NodePort --port=4466 service/headlamp exposed $ kubectl get service headlamp -n kube-system NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE headlamp NodePort 10.99.144.210 <none> 4466:30712/TCP 6m57s $ minikube service headlamp -n kube-system --url http://192.168.49.2:30342 Go to the URL printed by minikube in your browser, and get your token to login.","title":"Create a deployment yaml."},{"location":"development/_index/#shipping-plugins-in-the-docker-image","text":"Since the Headlamp server has an option ( -plugins-dir ) for indicating where to find any plugins, a deployment of Headlamp using the Docker image can mount a plugins folder and point to it by using the mentioned option. An alternative is to build an image that ships some plugins in it. For that, just create a \".plugins\" folder in the Headlamp project directory as the Dockerfile will include it and point to it by default.","title":"Shipping plugins in the Docker image"},{"location":"development/backend/","text":"Headlamp's backend is written in Go and is in charge of redirecting the client requests to the right clusters, as well as to return any available plugins for the client to use. The backend most basic and essential function is to read the cluster information from the given configuration, and set up proxies to the defined clusters as well as endpoints to them. This means that instead of having a set of endpoints related to the functionality available to the client, it simply redirects the requests to the defined proxies. Building and running The backend (Headlamp's server) can be quickly built using: make backend Once built, it can be run in development mode (insecure / don't use in production) using: make run-backend","title":"Backend"},{"location":"development/backend/#building-and-running","text":"The backend (Headlamp's server) can be quickly built using: make backend Once built, it can be run in development mode (insecure / don't use in production) using: make run-backend","title":"Building and running"},{"location":"development/frontend/","text":"The frontend is written in Typescript and React, as well as a few other important modules like: * Material UI * React Router * Redux * Redux Sagas Building and running The frontend can be quickly built using: make frontend Once built, it can be run in development mode (auto-refresh) using: make run-frontend This command leverages the create-react-app 's start script that launches a development server for the frontend (by default at localhost:3000 ). API documentation API documentation for TypeScript is done with typedoc and typedoc-plugin-markdown , and is configured in tsconfig.json make docs The API output mardown is generated in docs/development/api and is not committed to git, but is shown on the website at headlamp/latest/development/api Storybook Components can be discovered, developed and tested inside the 'storybook'. From within the Headlamp repo run: make storybook","title":"Frontend"},{"location":"development/frontend/#building-and-running","text":"The frontend can be quickly built using: make frontend Once built, it can be run in development mode (auto-refresh) using: make run-frontend This command leverages the create-react-app 's start script that launches a development server for the frontend (by default at localhost:3000 ).","title":"Building and running"},{"location":"development/frontend/#api-documentation","text":"API documentation for TypeScript is done with typedoc and typedoc-plugin-markdown , and is configured in tsconfig.json make docs The API output mardown is generated in docs/development/api and is not committed to git, but is shown on the website at headlamp/latest/development/api","title":"API documentation"},{"location":"development/frontend/#storybook","text":"Components can be discovered, developed and tested inside the 'storybook'. From within the Headlamp repo run: make storybook","title":"Storybook"},{"location":"development/api/","text":"Modules lib/k8s lib/util plugin plugin/registry","title":"API"},{"location":"development/api/#modules","text":"lib/k8s lib/util plugin plugin/registry","title":"Modules"},{"location":"development/api/_index/","text":"Modules lib/k8s lib/util plugin plugin/registry","title":"API"},{"location":"development/api/_index/#modules","text":"lib/k8s lib/util plugin plugin/registry","title":"Modules"},{"location":"development/api/classes/","text":"title: \"Classes\"","title":"Index"},{"location":"development/api/classes/#title-classes","text":"","title":"title: \"Classes\""},{"location":"development/api/classes/_index/","text":"title: \"Classes\"","title":" index"},{"location":"development/api/classes/_index/#title-classes","text":"","title":"title: \"Classes\""},{"location":"development/api/classes/plugin.Plugin/","text":"plugin .Plugin Plugins should call registerPlugin(pluginId: string, pluginObj: Plugin) to register themselves. They will have their initialize(register) method called at plugin initialization time. Constructors constructor \u2022 new Plugin () Methods initialize \u25b8 Abstract initialize ( register ): boolean initialize is called for each plugin with a Registry which gives the plugin methods for doing things. see Registry Parameters Name Type register default Returns boolean Defined in plugin/index.tsx:86","title":"Class: Plugin"},{"location":"development/api/classes/plugin.Plugin/#constructors","text":"","title":"Constructors"},{"location":"development/api/classes/plugin.Plugin/#constructor","text":"\u2022 new Plugin ()","title":"constructor"},{"location":"development/api/classes/plugin.Plugin/#methods","text":"","title":"Methods"},{"location":"development/api/classes/plugin.Plugin/#initialize","text":"\u25b8 Abstract initialize ( register ): boolean initialize is called for each plugin with a Registry which gives the plugin methods for doing things. see Registry","title":"initialize"},{"location":"development/api/classes/plugin.Plugin/#parameters","text":"Name Type register default","title":"Parameters"},{"location":"development/api/classes/plugin.Plugin/#returns","text":"boolean","title":"Returns"},{"location":"development/api/classes/plugin.Plugin/#defined-in","text":"plugin/index.tsx:86","title":"Defined in"},{"location":"development/api/classes/plugin_registry.default/","text":"plugin/registry .default Constructors constructor \u2022 new default () Methods registerAppBarAction \u25b8 registerAppBarAction ( actionName , actionFunc ): void Add a component into the app bar (at the top of the app). example register.registerAppBarAction('monitor', () => <MonitorLink /> ); Parameters Name Type Description actionName string a unique name for it actionFunc (... args : any []) => null | Element a function that returns your component Returns void Defined in plugin/registry.tsx:101 registerDetailsViewHeaderAction \u25b8 registerDetailsViewHeaderAction ( actionName , actionFunc ): void Add a component into the details view header. example register.registerDetailsViewHeaderAction('traces', (props) => <TraceIcon {...props} /> ); Parameters Name Type Description actionName string a unique name for it actionFunc (... args : any []) => null | Element a function that returns your component with props to pass into it. Returns void Defined in plugin/registry.tsx:82 registerRoute \u25b8 registerRoute ( routeSpec ): void Add a Route for a component. see Route examples example // Add a route that will display the given component and select // the \"traces\" sidebar item. register.registerRoute({ path: '/traces', sidebar: 'traces', component: () => <TraceList /> }); Parameters Name Type Description routeSpec Route details of URL, highlighted sidebar and component to use. Returns void Defined in plugin/registry.tsx:63 registerSidebarItem \u25b8 registerSidebarItem ( parentName , itemName , itemLabel , url , opts? ): void Add a SidebarItem. example registerSidebarItem('cluster', 'traces', 'Traces', '/traces'); Parameters Name Type Default value Description parentName string undefined the name of the parent SidebarItem. itemName string undefined name of this SidebarItem. itemLabel string undefined label to display. url string undefined the URL to go to, when this item is followed. opts Object undefined ... todo opts.useClusterURL boolean true - Returns void Defined in plugin/registry.tsx:26","title":"Class: default"},{"location":"development/api/classes/plugin_registry.default/#constructors","text":"","title":"Constructors"},{"location":"development/api/classes/plugin_registry.default/#constructor","text":"\u2022 new default ()","title":"constructor"},{"location":"development/api/classes/plugin_registry.default/#methods","text":"","title":"Methods"},{"location":"development/api/classes/plugin_registry.default/#registerappbaraction","text":"\u25b8 registerAppBarAction ( actionName , actionFunc ): void Add a component into the app bar (at the top of the app). example register.registerAppBarAction('monitor', () => <MonitorLink /> );","title":"registerAppBarAction"},{"location":"development/api/classes/plugin_registry.default/#parameters","text":"Name Type Description actionName string a unique name for it actionFunc (... args : any []) => null | Element a function that returns your component","title":"Parameters"},{"location":"development/api/classes/plugin_registry.default/#returns","text":"void","title":"Returns"},{"location":"development/api/classes/plugin_registry.default/#defined-in","text":"plugin/registry.tsx:101","title":"Defined in"},{"location":"development/api/classes/plugin_registry.default/#registerdetailsviewheaderaction","text":"\u25b8 registerDetailsViewHeaderAction ( actionName , actionFunc ): void Add a component into the details view header. example register.registerDetailsViewHeaderAction('traces', (props) => <TraceIcon {...props} /> );","title":"registerDetailsViewHeaderAction"},{"location":"development/api/classes/plugin_registry.default/#parameters_1","text":"Name Type Description actionName string a unique name for it actionFunc (... args : any []) => null | Element a function that returns your component with props to pass into it.","title":"Parameters"},{"location":"development/api/classes/plugin_registry.default/#returns_1","text":"void","title":"Returns"},{"location":"development/api/classes/plugin_registry.default/#defined-in_1","text":"plugin/registry.tsx:82","title":"Defined in"},{"location":"development/api/classes/plugin_registry.default/#registerroute","text":"\u25b8 registerRoute ( routeSpec ): void Add a Route for a component. see Route examples example // Add a route that will display the given component and select // the \"traces\" sidebar item. register.registerRoute({ path: '/traces', sidebar: 'traces', component: () => <TraceList /> });","title":"registerRoute"},{"location":"development/api/classes/plugin_registry.default/#parameters_2","text":"Name Type Description routeSpec Route details of URL, highlighted sidebar and component to use.","title":"Parameters"},{"location":"development/api/classes/plugin_registry.default/#returns_2","text":"void","title":"Returns"},{"location":"development/api/classes/plugin_registry.default/#defined-in_2","text":"plugin/registry.tsx:63","title":"Defined in"},{"location":"development/api/classes/plugin_registry.default/#registersidebaritem","text":"\u25b8 registerSidebarItem ( parentName , itemName , itemLabel , url , opts? ): void Add a SidebarItem. example registerSidebarItem('cluster', 'traces', 'Traces', '/traces');","title":"registerSidebarItem"},{"location":"development/api/classes/plugin_registry.default/#parameters_3","text":"Name Type Default value Description parentName string undefined the name of the parent SidebarItem. itemName string undefined name of this SidebarItem. itemLabel string undefined label to display. url string undefined the URL to go to, when this item is followed. opts Object undefined ... todo opts.useClusterURL boolean true -","title":"Parameters"},{"location":"development/api/classes/plugin_registry.default/#returns_3","text":"void","title":"Returns"},{"location":"development/api/classes/plugin_registry.default/#defined-in_3","text":"plugin/registry.tsx:26","title":"Defined in"},{"location":"development/api/interfaces/","text":"title: \"Interfaces\"","title":"Index"},{"location":"development/api/interfaces/#title-interfaces","text":"","title":"title: \"Interfaces\""},{"location":"development/api/interfaces/_index/","text":"title: \"Interfaces\"","title":" index"},{"location":"development/api/interfaces/_index/#title-interfaces","text":"","title":"title: \"Interfaces\""},{"location":"development/api/interfaces/lib_util.filterstate/","text":"lib/util .FilterState Properties namespaces \u2022 namespaces : Set < string > Defined in lib/util.ts:80 search \u2022 search : string Defined in lib/util.ts:81","title":"Interface: FilterState"},{"location":"development/api/interfaces/lib_util.filterstate/#properties","text":"","title":"Properties"},{"location":"development/api/interfaces/lib_util.filterstate/#namespaces","text":"\u2022 namespaces : Set < string >","title":"namespaces"},{"location":"development/api/interfaces/lib_util.filterstate/#defined-in","text":"lib/util.ts:80","title":"Defined in"},{"location":"development/api/interfaces/lib_util.filterstate/#search","text":"\u2022 search : string","title":"search"},{"location":"development/api/interfaces/lib_util.filterstate/#defined-in_1","text":"lib/util.ts:81","title":"Defined in"},{"location":"development/api/modules/","text":"title: \"Modules\"","title":"Index"},{"location":"development/api/modules/#title-modules","text":"","title":"title: \"Modules\""},{"location":"development/api/modules/_index/","text":"title: \"Modules\"","title":" index"},{"location":"development/api/modules/_index/#title-modules","text":"","title":"title: \"Modules\""},{"location":"development/api/modules/lib_k8s/","text":"Variables ResourceClasses \u2022 Const ResourceClasses : Object Index signature \u25aa [className: string ]: KubeObject Defined in lib/k8s/index.ts:71 Functions getVersion \u25b8 getVersion (): Promise < StringDict > Returns Promise < StringDict > Defined in lib/k8s/index.ts:143 useCluster \u25b8 useCluster (): null | string Returns null | string Defined in lib/k8s/index.ts:126 useClustersConf \u25b8 useClustersConf (): ConfigState [ \"clusters\" ] Returns ConfigState [ \"clusters\" ] Defined in lib/k8s/index.ts:78 useConnectApi \u25b8 useConnectApi (... apiCalls ): void Parameters Name Type ...apiCalls () => CancellablePromise [] Returns void Defined in lib/k8s/index.ts:149","title":"Module: lib/k8s"},{"location":"development/api/modules/lib_k8s/#variables","text":"","title":"Variables"},{"location":"development/api/modules/lib_k8s/#resourceclasses","text":"\u2022 Const ResourceClasses : Object","title":"ResourceClasses"},{"location":"development/api/modules/lib_k8s/#index-signature","text":"\u25aa [className: string ]: KubeObject","title":"Index signature"},{"location":"development/api/modules/lib_k8s/#defined-in","text":"lib/k8s/index.ts:71","title":"Defined in"},{"location":"development/api/modules/lib_k8s/#functions","text":"","title":"Functions"},{"location":"development/api/modules/lib_k8s/#getversion","text":"\u25b8 getVersion (): Promise < StringDict >","title":"getVersion"},{"location":"development/api/modules/lib_k8s/#returns","text":"Promise < StringDict >","title":"Returns"},{"location":"development/api/modules/lib_k8s/#defined-in_1","text":"lib/k8s/index.ts:143","title":"Defined in"},{"location":"development/api/modules/lib_k8s/#usecluster","text":"\u25b8 useCluster (): null | string","title":"useCluster"},{"location":"development/api/modules/lib_k8s/#returns_1","text":"null | string","title":"Returns"},{"location":"development/api/modules/lib_k8s/#defined-in_2","text":"lib/k8s/index.ts:126","title":"Defined in"},{"location":"development/api/modules/lib_k8s/#useclustersconf","text":"\u25b8 useClustersConf (): ConfigState [ \"clusters\" ]","title":"useClustersConf"},{"location":"development/api/modules/lib_k8s/#returns_2","text":"ConfigState [ \"clusters\" ]","title":"Returns"},{"location":"development/api/modules/lib_k8s/#defined-in_3","text":"lib/k8s/index.ts:78","title":"Defined in"},{"location":"development/api/modules/lib_k8s/#useconnectapi","text":"\u25b8 useConnectApi (... apiCalls ): void","title":"useConnectApi"},{"location":"development/api/modules/lib_k8s/#parameters","text":"Name Type ...apiCalls () => CancellablePromise []","title":"Parameters"},{"location":"development/api/modules/lib_k8s/#returns_3","text":"void","title":"Returns"},{"location":"development/api/modules/lib_k8s/#defined-in_4","text":"lib/k8s/index.ts:149","title":"Defined in"},{"location":"development/api/modules/lib_util/","text":"Interfaces FilterState Variables CLUSTER_ACTION_GRACE_PERIOD \u2022 Const CLUSTER_ACTION_GRACE_PERIOD : 5000 Defined in lib/util.ts:17 Functions filterResource \u25b8 filterResource ( item , filter ): boolean Parameters Name Type item KubeObjectInterface filter FilterState Returns boolean Defined in lib/util.ts:84 getCluster \u25b8 getCluster (): string | null Returns string | null Defined in lib/util.ts:119 getClusterPrefixedPath \u25b8 getClusterPrefixedPath ( path? ): string Parameters Name Type path? string | null Returns string Defined in lib/util.ts:111 getPercentStr \u25b8 getPercentStr ( value , total ): null | string Parameters Name Type value number total number Returns null | string Defined in lib/util.ts:33 getReadyReplicas \u25b8 getReadyReplicas ( item ): any Parameters Name Type item Workload Returns any Defined in lib/util.ts:42 getResourceMetrics \u25b8 getResourceMetrics ( item , metrics , resourceType ): any [] Parameters Name Type item Node metrics KubeMetrics [] resourceType \"cpu\" | \"memory\" Returns any [] Defined in lib/util.ts:60 getResourceStr \u25b8 getResourceStr ( value , resourceType ): string Parameters Name Type value number resourceType \"cpu\" | \"memory\" Returns string Defined in lib/util.ts:50 getTotalReplicas \u25b8 getTotalReplicas ( item ): any Parameters Name Type item Workload Returns any Defined in lib/util.ts:46 localeDate \u25b8 localeDate ( date ): string Parameters Name Type date DateParam Returns string Defined in lib/util.ts:25 timeAgo \u25b8 timeAgo ( date ): string Parameters Name Type date DateParam Returns string Defined in lib/util.ts:21 useErrorState \u25b8 useErrorState ( dependentSetter? ): any [] Parameters Name Type dependentSetter? (... args : any ) => void Returns any [] Defined in lib/util.ts:131 useFilterFunc \u25b8 useFilterFunc (): ( item : KubeObjectInterface ) => boolean Returns fn \u25b8 ( item ): boolean Parameters Name Type item KubeObjectInterface Returns boolean Defined in lib/util.ts:106","title":"Module: lib/util"},{"location":"development/api/modules/lib_util/#interfaces","text":"FilterState","title":"Interfaces"},{"location":"development/api/modules/lib_util/#variables","text":"","title":"Variables"},{"location":"development/api/modules/lib_util/#cluster_action_grace_period","text":"\u2022 Const CLUSTER_ACTION_GRACE_PERIOD : 5000","title":"CLUSTER_ACTION_GRACE_PERIOD"},{"location":"development/api/modules/lib_util/#defined-in","text":"lib/util.ts:17","title":"Defined in"},{"location":"development/api/modules/lib_util/#functions","text":"","title":"Functions"},{"location":"development/api/modules/lib_util/#filterresource","text":"\u25b8 filterResource ( item , filter ): boolean","title":"filterResource"},{"location":"development/api/modules/lib_util/#parameters","text":"Name Type item KubeObjectInterface filter FilterState","title":"Parameters"},{"location":"development/api/modules/lib_util/#returns","text":"boolean","title":"Returns"},{"location":"development/api/modules/lib_util/#defined-in_1","text":"lib/util.ts:84","title":"Defined in"},{"location":"development/api/modules/lib_util/#getcluster","text":"\u25b8 getCluster (): string | null","title":"getCluster"},{"location":"development/api/modules/lib_util/#returns_1","text":"string | null","title":"Returns"},{"location":"development/api/modules/lib_util/#defined-in_2","text":"lib/util.ts:119","title":"Defined in"},{"location":"development/api/modules/lib_util/#getclusterprefixedpath","text":"\u25b8 getClusterPrefixedPath ( path? ): string","title":"getClusterPrefixedPath"},{"location":"development/api/modules/lib_util/#parameters_1","text":"Name Type path? string | null","title":"Parameters"},{"location":"development/api/modules/lib_util/#returns_2","text":"string","title":"Returns"},{"location":"development/api/modules/lib_util/#defined-in_3","text":"lib/util.ts:111","title":"Defined in"},{"location":"development/api/modules/lib_util/#getpercentstr","text":"\u25b8 getPercentStr ( value , total ): null | string","title":"getPercentStr"},{"location":"development/api/modules/lib_util/#parameters_2","text":"Name Type value number total number","title":"Parameters"},{"location":"development/api/modules/lib_util/#returns_3","text":"null | string","title":"Returns"},{"location":"development/api/modules/lib_util/#defined-in_4","text":"lib/util.ts:33","title":"Defined in"},{"location":"development/api/modules/lib_util/#getreadyreplicas","text":"\u25b8 getReadyReplicas ( item ): any","title":"getReadyReplicas"},{"location":"development/api/modules/lib_util/#parameters_3","text":"Name Type item Workload","title":"Parameters"},{"location":"development/api/modules/lib_util/#returns_4","text":"any","title":"Returns"},{"location":"development/api/modules/lib_util/#defined-in_5","text":"lib/util.ts:42","title":"Defined in"},{"location":"development/api/modules/lib_util/#getresourcemetrics","text":"\u25b8 getResourceMetrics ( item , metrics , resourceType ): any []","title":"getResourceMetrics"},{"location":"development/api/modules/lib_util/#parameters_4","text":"Name Type item Node metrics KubeMetrics [] resourceType \"cpu\" | \"memory\"","title":"Parameters"},{"location":"development/api/modules/lib_util/#returns_5","text":"any []","title":"Returns"},{"location":"development/api/modules/lib_util/#defined-in_6","text":"lib/util.ts:60","title":"Defined in"},{"location":"development/api/modules/lib_util/#getresourcestr","text":"\u25b8 getResourceStr ( value , resourceType ): string","title":"getResourceStr"},{"location":"development/api/modules/lib_util/#parameters_5","text":"Name Type value number resourceType \"cpu\" | \"memory\"","title":"Parameters"},{"location":"development/api/modules/lib_util/#returns_6","text":"string","title":"Returns"},{"location":"development/api/modules/lib_util/#defined-in_7","text":"lib/util.ts:50","title":"Defined in"},{"location":"development/api/modules/lib_util/#gettotalreplicas","text":"\u25b8 getTotalReplicas ( item ): any","title":"getTotalReplicas"},{"location":"development/api/modules/lib_util/#parameters_6","text":"Name Type item Workload","title":"Parameters"},{"location":"development/api/modules/lib_util/#returns_7","text":"any","title":"Returns"},{"location":"development/api/modules/lib_util/#defined-in_8","text":"lib/util.ts:46","title":"Defined in"},{"location":"development/api/modules/lib_util/#localedate","text":"\u25b8 localeDate ( date ): string","title":"localeDate"},{"location":"development/api/modules/lib_util/#parameters_7","text":"Name Type date DateParam","title":"Parameters"},{"location":"development/api/modules/lib_util/#returns_8","text":"string","title":"Returns"},{"location":"development/api/modules/lib_util/#defined-in_9","text":"lib/util.ts:25","title":"Defined in"},{"location":"development/api/modules/lib_util/#timeago","text":"\u25b8 timeAgo ( date ): string","title":"timeAgo"},{"location":"development/api/modules/lib_util/#parameters_8","text":"Name Type date DateParam","title":"Parameters"},{"location":"development/api/modules/lib_util/#returns_9","text":"string","title":"Returns"},{"location":"development/api/modules/lib_util/#defined-in_10","text":"lib/util.ts:21","title":"Defined in"},{"location":"development/api/modules/lib_util/#useerrorstate","text":"\u25b8 useErrorState ( dependentSetter? ): any []","title":"useErrorState"},{"location":"development/api/modules/lib_util/#parameters_9","text":"Name Type dependentSetter? (... args : any ) => void","title":"Parameters"},{"location":"development/api/modules/lib_util/#returns_10","text":"any []","title":"Returns"},{"location":"development/api/modules/lib_util/#defined-in_11","text":"lib/util.ts:131","title":"Defined in"},{"location":"development/api/modules/lib_util/#usefilterfunc","text":"\u25b8 useFilterFunc (): ( item : KubeObjectInterface ) => boolean","title":"useFilterFunc"},{"location":"development/api/modules/lib_util/#returns_11","text":"fn \u25b8 ( item ): boolean","title":"Returns"},{"location":"development/api/modules/lib_util/#parameters_10","text":"Name Type item KubeObjectInterface","title":"Parameters"},{"location":"development/api/modules/lib_util/#returns_12","text":"boolean","title":"Returns"},{"location":"development/api/modules/lib_util/#defined-in_12","text":"lib/util.ts:106","title":"Defined in"},{"location":"development/api/modules/plugin/","text":"Classes Plugin Functions initializePlugins \u25b8 initializePlugins (): Promise < unknown > Load external, then local plugins. Then initialize() them in order with a Registry. Returns Promise < unknown > Defined in plugin/index.tsx:211","title":"Module: plugin"},{"location":"development/api/modules/plugin/#classes","text":"Plugin","title":"Classes"},{"location":"development/api/modules/plugin/#functions","text":"","title":"Functions"},{"location":"development/api/modules/plugin/#initializeplugins","text":"\u25b8 initializePlugins (): Promise < unknown > Load external, then local plugins. Then initialize() them in order with a Registry.","title":"initializePlugins"},{"location":"development/api/modules/plugin/#returns","text":"Promise < unknown >","title":"Returns"},{"location":"development/api/modules/plugin/#defined-in","text":"plugin/index.tsx:211","title":"Defined in"},{"location":"development/api/modules/plugin_registry/","text":"Classes default","title":"Module: plugin/registry"},{"location":"development/api/modules/plugin_registry/#classes","text":"default","title":"Classes"},{"location":"development/i18n/","text":"Headlamp's internationalization uses the i18next, i18next-parser, and react-i18next libraries. Default language, and locales We started with an international English, and that will be the fallback language. Now we're starting with locales familiar, and will accept translations through github. Browser based language detection We use i18next-browser-languagedetector This can select the browser language through various means like through cookies, the html language tag and other ways. One way to change the locale is to use ?lng=en in the URL. Lazy load locale files Dynamic imports and the webpack code splitting feature we load locale files from src/i18n/locales/{{lng}}/{{ns}}.json where {{lng}} is the language code, and {{ns}} is the namespace.","title":"i18n Internationalization / Localization"},{"location":"development/i18n/#default-language-and-locales","text":"We started with an international English, and that will be the fallback language. Now we're starting with locales familiar, and will accept translations through github.","title":"Default language, and locales"},{"location":"development/i18n/#browser-based-language-detection","text":"We use i18next-browser-languagedetector This can select the browser language through various means like through cookies, the html language tag and other ways. One way to change the locale is to use ?lng=en in the URL.","title":"Browser based language detection"},{"location":"development/i18n/#lazy-load-locale-files","text":"Dynamic imports and the webpack code splitting feature we load locale files from src/i18n/locales/{{lng}}/{{ns}}.json where {{lng}} is the language code, and {{ns}} is the namespace.","title":"Lazy load locale files"},{"location":"development/i18n/_index/","text":"Headlamp's internationalization uses the i18next, i18next-parser, and react-i18next libraries. Default language, and locales We started with an international English, and that will be the fallback language. Now we're starting with locales familiar, and will accept translations through github. Browser based language detection We use i18next-browser-languagedetector This can select the browser language through various means like through cookies, the html language tag and other ways. One way to change the locale is to use ?lng=en in the URL. Lazy load locale files Dynamic imports and the webpack code splitting feature we load locale files from src/i18n/locales/{{lng}}/{{ns}}.json where {{lng}} is the language code, and {{ns}} is the namespace.","title":"i18n Internationalization / Localization"},{"location":"development/i18n/_index/#default-language-and-locales","text":"We started with an international English, and that will be the fallback language. Now we're starting with locales familiar, and will accept translations through github.","title":"Default language, and locales"},{"location":"development/i18n/_index/#browser-based-language-detection","text":"We use i18next-browser-languagedetector This can select the browser language through various means like through cookies, the html language tag and other ways. One way to change the locale is to use ?lng=en in the URL.","title":"Browser based language detection"},{"location":"development/i18n/_index/#lazy-load-locale-files","text":"Dynamic imports and the webpack code splitting feature we load locale files from src/i18n/locales/{{lng}}/{{ns}}.json where {{lng}} is the language code, and {{ns}} is the namespace.","title":"Lazy load locale files"},{"location":"development/i18n/contributing/","text":"This section introduces some concepts for contributing translations, and is especially important when submitting a new language. Important: If you are adding a new language, keep in mind that while all the specific Kubernetes components' names are translatable, it doesn't mean that all of them should have a corresponding name in your language. Please, refer to the Kubernetes localized docs in your language (if they exist) in order to understand which components should be translated and which should be left in the original form. Namespaces i18next namespaces are useful to keep things modular. We have a namespace for each app section, and also some frequently used global parts. Namespaces are separated from the actual text by a | character. E.g. t('mynamescapce|This will be the translated text') . Frequent, and Glossary namespaces Additionally we have some global namespaces for frequently used and jargony technical words. frequent.json, Phrases reused many times, eg. 'save', 'cancel' glossary.json, Reusing these consistently inside texts like jargon words (Pods) Technical Jargon words For some technical/jargon terms there often isn't a good translation for them. To find these ones, it can be good to look at existing documentation like the k8s docs. The word \"Pods\" is a good example of a technical word that is used in Spanish. Maybe it could directly translate to \"Vainas\", but \"Pods\" is used instead. https://kubernetes.io/es/docs/concepts/workloads/pods/pod/ https://kubernetes.io/docs/concepts/workloads/pods/pod/ Number formatting Numbers are formatted in a locale specific way. For example in 'en' they are formatted like 1,000,000 but with 'de' they are formatted like 1.000.000 . Here is an example which can use number formatting: return t('cluster:{{numReady, number}} / {{numItems, number}} Requested', { numReady: podsReady.length, numItems: items.length, }); Number formatting is being done with Intl.NumberFormat . Date formatting Here's an example of using date formatting: return t('appsection:When {{ date, date }}', { date: new Date(), }); Adding a new component. See the frontend/src/i18n/locales/en/ folder for a complete list of namespaces. If you need a new namespace (e.g. when you're using a sentence that's very specific to a single/new component), use that namespace as you would if it already existed. Then run make i18n and a new translation file for that namespace will show up in all locale folders. Adding a new language. Create a folder using the locale code in: frontend/src/i18n/locales/ and app/electron/locales Then run make i18n . This command parses the translatable strings in the project and creates the corresponding catalog files. Integrated components may need to be adjusted (MaterialUI/Monaco etc). Material UI Some Material UI components are localized, and are configured via a theme provider. See the Material UI Localization Guide , and also frontend/src/i18n/ThemeProviderNexti18n.tsx where integration is done. Storybook integration TODO: not implmented. There's no working addons that let you set a language easily. Monaco editor integration See frontend/src/components/common/Resource/EditorDialog.tsx Note, that Monaco editor does not support pt, ta and other languages.","title":"Contributing to Internationalization"},{"location":"development/i18n/contributing/#namespaces","text":"i18next namespaces are useful to keep things modular. We have a namespace for each app section, and also some frequently used global parts. Namespaces are separated from the actual text by a | character. E.g. t('mynamescapce|This will be the translated text') .","title":"Namespaces"},{"location":"development/i18n/contributing/#frequent-and-glossary-namespaces","text":"Additionally we have some global namespaces for frequently used and jargony technical words. frequent.json, Phrases reused many times, eg. 'save', 'cancel' glossary.json, Reusing these consistently inside texts like jargon words (Pods)","title":"Frequent, and Glossary namespaces"},{"location":"development/i18n/contributing/#technical-jargon-words","text":"For some technical/jargon terms there often isn't a good translation for them. To find these ones, it can be good to look at existing documentation like the k8s docs. The word \"Pods\" is a good example of a technical word that is used in Spanish. Maybe it could directly translate to \"Vainas\", but \"Pods\" is used instead. https://kubernetes.io/es/docs/concepts/workloads/pods/pod/ https://kubernetes.io/docs/concepts/workloads/pods/pod/","title":"Technical Jargon words"},{"location":"development/i18n/contributing/#number-formatting","text":"Numbers are formatted in a locale specific way. For example in 'en' they are formatted like 1,000,000 but with 'de' they are formatted like 1.000.000 . Here is an example which can use number formatting: return t('cluster:{{numReady, number}} / {{numItems, number}} Requested', { numReady: podsReady.length, numItems: items.length, }); Number formatting is being done with Intl.NumberFormat .","title":"Number formatting"},{"location":"development/i18n/contributing/#date-formatting","text":"Here's an example of using date formatting: return t('appsection:When {{ date, date }}', { date: new Date(), });","title":"Date formatting"},{"location":"development/i18n/contributing/#adding-a-new-component","text":"See the frontend/src/i18n/locales/en/ folder for a complete list of namespaces. If you need a new namespace (e.g. when you're using a sentence that's very specific to a single/new component), use that namespace as you would if it already existed. Then run make i18n and a new translation file for that namespace will show up in all locale folders.","title":"Adding a new component."},{"location":"development/i18n/contributing/#adding-a-new-language","text":"Create a folder using the locale code in: frontend/src/i18n/locales/ and app/electron/locales Then run make i18n . This command parses the translatable strings in the project and creates the corresponding catalog files. Integrated components may need to be adjusted (MaterialUI/Monaco etc).","title":"Adding a new language."},{"location":"development/i18n/contributing/#material-ui","text":"Some Material UI components are localized, and are configured via a theme provider. See the Material UI Localization Guide , and also frontend/src/i18n/ThemeProviderNexti18n.tsx where integration is done.","title":"Material UI"},{"location":"development/i18n/contributing/#storybook-integration","text":"TODO: not implmented. There's no working addons that let you set a language easily.","title":"Storybook integration"},{"location":"development/i18n/contributing/#monaco-editor-integration","text":"See frontend/src/components/common/Resource/EditorDialog.tsx Note, that Monaco editor does not support pt, ta and other languages.","title":"Monaco editor integration"},{"location":"development/plugins/","text":"Plugins are one of the key features of Headlamp. They allow you to change how and what information is displayed, as well as other functionality. The ultimate goal of the plugins system is to allow vendors to build and deploy Headlamp with extra functionality without having to maintain a fork of the project. Using plugins Headlamp looks for plugins in different places. It looks at the Headlamp's configuration folder first: On a Mac and Linux desktop, the plugins folder is by default: $HOME/.config/Headlamp/plugins On Windows, it is by default: $APPDATA/Headlamp/plugins In the plugins directory, plugins should be in the following format: MyPlugin1/ main.js MyPlugin2/ main.js MyPlugin3/ main.js See the shipping & deploying plugins section for more details. Developing Plugins Plugins are supposed to be built and shipped out-of-tree, i.e. instead of managing the plugins' code within the Headlamp project or a Headlamp fork (which would require always rebuilding/maintaining Headlamp when changing a plugin), they're supposed to be built outside of the project and loaded by Headlamp. Learn how to create a Headlamp plugin .","title":"Plugins"},{"location":"development/plugins/#using-plugins","text":"Headlamp looks for plugins in different places. It looks at the Headlamp's configuration folder first: On a Mac and Linux desktop, the plugins folder is by default: $HOME/.config/Headlamp/plugins On Windows, it is by default: $APPDATA/Headlamp/plugins In the plugins directory, plugins should be in the following format: MyPlugin1/ main.js MyPlugin2/ main.js MyPlugin3/ main.js See the shipping & deploying plugins section for more details.","title":"Using plugins"},{"location":"development/plugins/#developing-plugins","text":"Plugins are supposed to be built and shipped out-of-tree, i.e. instead of managing the plugins' code within the Headlamp project or a Headlamp fork (which would require always rebuilding/maintaining Headlamp when changing a plugin), they're supposed to be built outside of the project and loaded by Headlamp. Learn how to create a Headlamp plugin .","title":"Developing Plugins"},{"location":"development/plugins/_index/","text":"Plugins are one of the key features of Headlamp. They allow you to change how and what information is displayed, as well as other functionality. The ultimate goal of the plugins system is to allow vendors to build and deploy Headlamp with extra functionality without having to maintain a fork of the project. Using plugins Headlamp looks for plugins in different places. It looks at the Headlamp's configuration folder first: On a Mac and Linux desktop, the plugins folder is by default: $HOME/.config/Headlamp/plugins On Windows, it is by default: $APPDATA/Headlamp/plugins In the plugins directory, plugins should be in the following format: MyPlugin1/ main.js MyPlugin2/ main.js MyPlugin3/ main.js See the shipping & deploying plugins section for more details. Developing Plugins Plugins are supposed to be built and shipped out-of-tree, i.e. instead of managing the plugins' code within the Headlamp project or a Headlamp fork (which would require always rebuilding/maintaining Headlamp when changing a plugin), they're supposed to be built outside of the project and loaded by Headlamp. Learn how to create a Headlamp plugin .","title":"Plugins"},{"location":"development/plugins/_index/#using-plugins","text":"Headlamp looks for plugins in different places. It looks at the Headlamp's configuration folder first: On a Mac and Linux desktop, the plugins folder is by default: $HOME/.config/Headlamp/plugins On Windows, it is by default: $APPDATA/Headlamp/plugins In the plugins directory, plugins should be in the following format: MyPlugin1/ main.js MyPlugin2/ main.js MyPlugin3/ main.js See the shipping & deploying plugins section for more details.","title":"Using plugins"},{"location":"development/plugins/_index/#developing-plugins","text":"Plugins are supposed to be built and shipped out-of-tree, i.e. instead of managing the plugins' code within the Headlamp project or a Headlamp fork (which would require always rebuilding/maintaining Headlamp when changing a plugin), they're supposed to be built outside of the project and loaded by Headlamp. Learn how to create a Headlamp plugin .","title":"Developing Plugins"},{"location":"development/plugins/building/","text":"This section explains how to start developing a Headlamp plugin, and how to ship it once finished. Creating a new plugin This is how to start a new plugin: npx @kinvolk/headlamp-plugin create headlamp-myfancy cd headlamp-myfancy npm run start Now run Headlamp (the desktop app or the development version ), and your plugin should be loaded. Using the above commands means that Headlamp will automatically reload whenever to make a change to the plugin. \u2139\ufe0f This automatic reload does not happen when running in-cluster, even if the plugins folder is changed. i.e. if you want to serve updated plugins, you need to restart the server. Building for production To build the previous plugin example for production, run the following command: cd headlamp-myfancy npm run build This will create a file with the bundled plugin in headlamp-myfancy/dist/main.js . Building a folder of packages at once For convienience the headlamp-plugin build command can build a package or folder of packages. npx @kinvolk/headlamp-plugin build myplugins/headlamp-myfancy npx @kinvolk/headlamp-plugin build myplugins Shipping / Deploying Plugins Once a plugin is ready to be shipped (built for production) it needs to be placed in a \"plugins directory\", for Headlamp to load them. For example, if we have built 3 plugins called MyPlugin1, MyPlugin2, and MyPlugin3, they should be added to a directory in the following structure: .plugins/ MyPlugin1/ main.js MyPlugin2/ main.js MyPlugin3/ main.js If our plugins are places in myplugins , we can conveniently create that folder with the following command: npx @kinvolk/headlamp-plugin extract ./myplugins /path/to/.plugins This also works individually (for each plugin): npx @kinvolk/headlamp-plugin extract ./myplugins/MyPlugin1 /path/to/./plugins In-cluster deployment with plugins For in-cluster Headlamp deployments, when running Headlamp's server, the -plugin-dir option should point to the directory: ./server -plugins-dir=.plugins Using plugins on the desktop version The Headlamp desktop app will look for the plugins directory (in the format mentioned above) either under the user's Headlamp configuration folder, or within the current folder as .plugins if the former doesn't exist.","title":"Building and Shipping Plugins"},{"location":"development/plugins/building/#creating-a-new-plugin","text":"This is how to start a new plugin: npx @kinvolk/headlamp-plugin create headlamp-myfancy cd headlamp-myfancy npm run start Now run Headlamp (the desktop app or the development version ), and your plugin should be loaded. Using the above commands means that Headlamp will automatically reload whenever to make a change to the plugin. \u2139\ufe0f This automatic reload does not happen when running in-cluster, even if the plugins folder is changed. i.e. if you want to serve updated plugins, you need to restart the server.","title":"Creating a new plugin"},{"location":"development/plugins/building/#building-for-production","text":"To build the previous plugin example for production, run the following command: cd headlamp-myfancy npm run build This will create a file with the bundled plugin in headlamp-myfancy/dist/main.js .","title":"Building for production"},{"location":"development/plugins/building/#building-a-folder-of-packages-at-once","text":"For convienience the headlamp-plugin build command can build a package or folder of packages. npx @kinvolk/headlamp-plugin build myplugins/headlamp-myfancy npx @kinvolk/headlamp-plugin build myplugins","title":"Building a folder of packages at once"},{"location":"development/plugins/building/#shipping-deploying-plugins","text":"Once a plugin is ready to be shipped (built for production) it needs to be placed in a \"plugins directory\", for Headlamp to load them. For example, if we have built 3 plugins called MyPlugin1, MyPlugin2, and MyPlugin3, they should be added to a directory in the following structure: .plugins/ MyPlugin1/ main.js MyPlugin2/ main.js MyPlugin3/ main.js If our plugins are places in myplugins , we can conveniently create that folder with the following command: npx @kinvolk/headlamp-plugin extract ./myplugins /path/to/.plugins This also works individually (for each plugin): npx @kinvolk/headlamp-plugin extract ./myplugins/MyPlugin1 /path/to/./plugins","title":"Shipping / Deploying Plugins"},{"location":"development/plugins/building/#in-cluster-deployment-with-plugins","text":"For in-cluster Headlamp deployments, when running Headlamp's server, the -plugin-dir option should point to the directory: ./server -plugins-dir=.plugins","title":"In-cluster deployment with plugins"},{"location":"development/plugins/building/#using-plugins-on-the-desktop-version","text":"The Headlamp desktop app will look for the plugins directory (in the format mentioned above) either under the user's Headlamp configuration folder, or within the current folder as .plugins if the former doesn't exist.","title":"Using plugins on the desktop version"},{"location":"development/plugins/functionality/","text":"Headlamp's plugins exist for changing or adding functionlity related to the user interface and experience. Plugins Lib Headlamp exposes a pluginLib object in the global object window . A number of modules, both from Headlamp, or representing Headlamp's common dependencies are included in the pluginLib . Thus, plugins should only use dependencies that are not yet provided by Headlamp. Modules External modules available currently in the pluginLib are: React Iconify ReactRedux MuiCore (Material UI's core module) MuiStyles (Material UI's styles module) Lodash Apart from the external modules above, the pluginLib contains of course modules that are related to Headlamp, so developers can use the cluster and web UI related functionality. Those modules are: K8s CommonComponents This means that you can just declare a const React = window.pluginLib.React in order to use React without having to import it. Registration Apart from the modules mentioned above, Headlamp also adds an important method for registering plugins ( window.registerPlugin ). Funcionality The plugin registers makes functionality available to plugins in an easy way. The idea is to make more and more functionality available to plugins. Here is what we have so far: Sidebar Items registerSidebarItem(parentName: string, itemName: string, itemLabel: string, url: string, opts = {useClusterURL: true}) This method allows to set entries in the sidebar. The arguments are as follows: parentName : The name of the parent entry. If the string is empty, then there is no parent, and that means the entry is a top-level one. For knowing which names exist already in the Sidebar, at the moment you have to check the configuration for that component, which can be found in Headlamp's src/components/Sidebar.tsx . itemName : The logical name for the item, i.e. the name other sub-entries will use when setting this item as a parent. itemLabel : The text to be displayed for the entry in the Sidebar. url : The URL to go to when clicking this entry. opts : The options related to registering this item. At the moment, only the useClusterUrl (defaults to true ) can be used. This option indicates whether the URL we are using for this entry should be prefixed with the current cluster URL or not. Most cluster related actions should have URLs that are prefixed by the cluster name and that's managed automatically with this option. Routes registerRoute(routeSpec: Route) interface Route { path: string; exact?: boolean; noCluster?: boolean; noAuthRequired?: boolean; sidebar: string | null; component: () => JSX.Element; } This method allows to register a route (i.e. a known URL that resolves to a component displayed in Headlamp's main area). The routeSpec is an object with the following members: path : The URL path for the route. exact (optional): There it should be an exact match between the URL's path and the one defined in the route spec (see ReactRouter 's docs for more context). By default it is false . noCluster (optional): Whether the route doesn't belongs to a cluster (in which case the URL produced for it will have the cluster prefix). By default it is false . noAuthRequired (optional): Whether authentication is not required for this route (example, non-cluster routes such as settings). By default it is false . sidebar : Which sidebar entry to select when this route is on (the value used should be an item name of the sidebar). component : The component to render in Headlamp's main area. Details Views' Header Actions registerDetailsViewHeaderAction(actionName: string, actionFunc: (item: object) => JSX.Element | null) This method allows to add a component to the top right area of details views (in the area of the screenshot below that's highlighted as yellow). Details views are the views used for displaying information about each cluster's resource. The arguments are as follows: actionName : The name for this action. actionFunc : A function that takes an item and returns an element (or null, if nothing should be done). App Bar Actions registerAppBarAction(actionName: string, actionFunc: () => JSX.Element | null)) This method allows to add a component to the top right area of the app bar (top bar). The arguments are as follows: actionName : The name for this action. actionFunc : A function that returns an element.","title":"Plugins Functionality"},{"location":"development/plugins/functionality/#plugins-lib","text":"Headlamp exposes a pluginLib object in the global object window . A number of modules, both from Headlamp, or representing Headlamp's common dependencies are included in the pluginLib . Thus, plugins should only use dependencies that are not yet provided by Headlamp.","title":"Plugins Lib"},{"location":"development/plugins/functionality/#modules","text":"External modules available currently in the pluginLib are: React Iconify ReactRedux MuiCore (Material UI's core module) MuiStyles (Material UI's styles module) Lodash Apart from the external modules above, the pluginLib contains of course modules that are related to Headlamp, so developers can use the cluster and web UI related functionality. Those modules are: K8s CommonComponents This means that you can just declare a const React = window.pluginLib.React in order to use React without having to import it.","title":"Modules"},{"location":"development/plugins/functionality/#registration","text":"Apart from the modules mentioned above, Headlamp also adds an important method for registering plugins ( window.registerPlugin ).","title":"Registration"},{"location":"development/plugins/functionality/#funcionality","text":"The plugin registers makes functionality available to plugins in an easy way. The idea is to make more and more functionality available to plugins. Here is what we have so far:","title":"Funcionality"},{"location":"development/plugins/functionality/#sidebar-items","text":"registerSidebarItem(parentName: string, itemName: string, itemLabel: string, url: string, opts = {useClusterURL: true}) This method allows to set entries in the sidebar. The arguments are as follows: parentName : The name of the parent entry. If the string is empty, then there is no parent, and that means the entry is a top-level one. For knowing which names exist already in the Sidebar, at the moment you have to check the configuration for that component, which can be found in Headlamp's src/components/Sidebar.tsx . itemName : The logical name for the item, i.e. the name other sub-entries will use when setting this item as a parent. itemLabel : The text to be displayed for the entry in the Sidebar. url : The URL to go to when clicking this entry. opts : The options related to registering this item. At the moment, only the useClusterUrl (defaults to true ) can be used. This option indicates whether the URL we are using for this entry should be prefixed with the current cluster URL or not. Most cluster related actions should have URLs that are prefixed by the cluster name and that's managed automatically with this option.","title":"Sidebar Items"},{"location":"development/plugins/functionality/#routes","text":"registerRoute(routeSpec: Route) interface Route { path: string; exact?: boolean; noCluster?: boolean; noAuthRequired?: boolean; sidebar: string | null; component: () => JSX.Element; } This method allows to register a route (i.e. a known URL that resolves to a component displayed in Headlamp's main area). The routeSpec is an object with the following members: path : The URL path for the route. exact (optional): There it should be an exact match between the URL's path and the one defined in the route spec (see ReactRouter 's docs for more context). By default it is false . noCluster (optional): Whether the route doesn't belongs to a cluster (in which case the URL produced for it will have the cluster prefix). By default it is false . noAuthRequired (optional): Whether authentication is not required for this route (example, non-cluster routes such as settings). By default it is false . sidebar : Which sidebar entry to select when this route is on (the value used should be an item name of the sidebar). component : The component to render in Headlamp's main area.","title":"Routes"},{"location":"development/plugins/functionality/#details-views-header-actions","text":"registerDetailsViewHeaderAction(actionName: string, actionFunc: (item: object) => JSX.Element | null) This method allows to add a component to the top right area of details views (in the area of the screenshot below that's highlighted as yellow). Details views are the views used for displaying information about each cluster's resource. The arguments are as follows: actionName : The name for this action. actionFunc : A function that takes an item and returns an element (or null, if nothing should be done).","title":"Details Views' Header Actions"},{"location":"development/plugins/functionality/#app-bar-actions","text":"registerAppBarAction(actionName: string, actionFunc: () => JSX.Element | null)) This method allows to add a component to the top right area of the app bar (top bar). The arguments are as follows: actionName : The name for this action. actionFunc : A function that returns an element.","title":"App Bar Actions"},{"location":"development/plugins/how-to/","text":"This section will walk you through a basic plugin development. Types If you are using Typescript for developing the plugin, the @kinvolk/headlamp-plugin package does ship some type declarations in @kinvolk/headlamp-plugin/types . Please notice that the whole external plugin mechanics are still in an early development phase and thus only the actual type declarations (and not the corresponding code) is shipped in this package at the moment. import { Plugin } from '@kinvolk/headlamp-plugin/types/plugin/index.d'; Plugin Class Plugins are classes that register actions when they are initialized. A plugin class needs an initialize method which receives a register class that offers ways to register different types of actions in the web UI. Besides declaring the plugin, an instance of it needs to be registered using the window.registerPlugin method. The following example will show a basic plugin declaration and registration in a file that should match the src/index.tsx structure explained in the building section. import { Plugin } from '@kinvolk/headlamp-plugin/types/plugin/index.d'; import Registry from '@kinvolk/headlamp-plugin/types/plugin/registry'; class MyPlugin implements Plugin { initialize(register: Registry) { // Actual actions registration goes here // At the moment the return value is ignored, but it will be used // to determine whether the plugin could be initialized. return true; } } window.registerPlugin('my-plugin', new MyPlugin()); Plugin Example Let's create a plugin that just gets the number of pods in the cluster and displays that information in the top bar (i.e. registers an \"app bar action\"). import { Plugin } from '@kinvolk/headlamp-plugin/types/plugin/index.d'; import Registry from '@kinvolk/headlamp-plugin/types/plugin/registry.d'; const pluginLib = window.pluginLib; const React = window.pluginLib.React; const K8s = pluginLib.K8s.ResourceClasses; const { Typography } = pluginLib.MuiCore; function PodCounter() { const [pods, error] = K8s.Pod.useList(); const msg = pods === null ? 'Loading\u2026' : pods.length.toString(); return ( <Typography color=\"textPrimary\">{!error ? `# Pods: ${msg}` : 'Uh, pods!?'}</Typography> ); } class PodCounterPlugin implements Plugin { initialize(register: Registry) { register.registerAppBarAction('monitor', () => <PodCounter /> ); return true; } } window.registerPlugin('pod-counter', new PodCounterPlugin()); Here is the result, running Headlamp with this plugin and using with a Minikube cluster: Please refer to the functionality section for learning about the different functionality that is available to plugins by the registry.","title":"How to create a Plugin"},{"location":"development/plugins/how-to/#types","text":"If you are using Typescript for developing the plugin, the @kinvolk/headlamp-plugin package does ship some type declarations in @kinvolk/headlamp-plugin/types . Please notice that the whole external plugin mechanics are still in an early development phase and thus only the actual type declarations (and not the corresponding code) is shipped in this package at the moment. import { Plugin } from '@kinvolk/headlamp-plugin/types/plugin/index.d';","title":"Types"},{"location":"development/plugins/how-to/#plugin-class","text":"Plugins are classes that register actions when they are initialized. A plugin class needs an initialize method which receives a register class that offers ways to register different types of actions in the web UI. Besides declaring the plugin, an instance of it needs to be registered using the window.registerPlugin method. The following example will show a basic plugin declaration and registration in a file that should match the src/index.tsx structure explained in the building section. import { Plugin } from '@kinvolk/headlamp-plugin/types/plugin/index.d'; import Registry from '@kinvolk/headlamp-plugin/types/plugin/registry'; class MyPlugin implements Plugin { initialize(register: Registry) { // Actual actions registration goes here // At the moment the return value is ignored, but it will be used // to determine whether the plugin could be initialized. return true; } } window.registerPlugin('my-plugin', new MyPlugin());","title":"Plugin Class"},{"location":"development/plugins/how-to/#plugin-example","text":"Let's create a plugin that just gets the number of pods in the cluster and displays that information in the top bar (i.e. registers an \"app bar action\"). import { Plugin } from '@kinvolk/headlamp-plugin/types/plugin/index.d'; import Registry from '@kinvolk/headlamp-plugin/types/plugin/registry.d'; const pluginLib = window.pluginLib; const React = window.pluginLib.React; const K8s = pluginLib.K8s.ResourceClasses; const { Typography } = pluginLib.MuiCore; function PodCounter() { const [pods, error] = K8s.Pod.useList(); const msg = pods === null ? 'Loading\u2026' : pods.length.toString(); return ( <Typography color=\"textPrimary\">{!error ? `# Pods: ${msg}` : 'Uh, pods!?'}</Typography> ); } class PodCounterPlugin implements Plugin { initialize(register: Registry) { register.registerAppBarAction('monitor', () => <PodCounter /> ); return true; } } window.registerPlugin('pod-counter', new PodCounterPlugin()); Here is the result, running Headlamp with this plugin and using with a Minikube cluster: Please refer to the functionality section for learning about the different functionality that is available to plugins by the registry.","title":"Plugin Example"},{"location":"installation/","text":"Headlamp can be deployed in a Kubernetes cluster, or run as a desktop application. Please check the guides in this section for installing the desktop application or deploying Headlamp in your cluster. Authentication / Log-in Currently you can log in Headlamp by using a client-certificate (as you may have configured with e.g. minikube), or a bearer token . Headlamp uses RBAC for checking whether and how users can access resources. This means that the recommended way to log in into Headlamp is to use a Service Account token. Create a Service Account token As an example, you can create a service account for using Headlamp and retrieve its token to authenticate: Create a Service Account: kubectl -n kube-system create serviceaccount headlamp-admin Give admin rights to the account (check the RBAC docs if you want to set more restrictive permissions): kubectl create clusterrolebinding headlamp-admin --serviceaccount=kube-system:headlamp-admin --clusterrole=cluster-admin Get the secret: kubectl -n kube-system get secrets | grep headlamp-admin Get the associated token: kubectl -n kube-system describe secret headlamp-admin-token-XXXXX Once you have the Service Account token, paste it when prompted by Headlamp. Use OIDC For OpenIDConnect, please see the in-cluster installation docs.","title":"Installation / Deployment"},{"location":"installation/#authentication-log-in","text":"Currently you can log in Headlamp by using a client-certificate (as you may have configured with e.g. minikube), or a bearer token . Headlamp uses RBAC for checking whether and how users can access resources. This means that the recommended way to log in into Headlamp is to use a Service Account token.","title":"Authentication / Log-in"},{"location":"installation/#create-a-service-account-token","text":"As an example, you can create a service account for using Headlamp and retrieve its token to authenticate: Create a Service Account: kubectl -n kube-system create serviceaccount headlamp-admin Give admin rights to the account (check the RBAC docs if you want to set more restrictive permissions): kubectl create clusterrolebinding headlamp-admin --serviceaccount=kube-system:headlamp-admin --clusterrole=cluster-admin Get the secret: kubectl -n kube-system get secrets | grep headlamp-admin Get the associated token: kubectl -n kube-system describe secret headlamp-admin-token-XXXXX Once you have the Service Account token, paste it when prompted by Headlamp.","title":"Create a Service Account token"},{"location":"installation/#use-oidc","text":"For OpenIDConnect, please see the in-cluster installation docs.","title":"Use OIDC"},{"location":"installation/_index/","text":"Headlamp can be deployed in a Kubernetes cluster, or run as a desktop application. Please check the guides in this section for installing the desktop application or deploying Headlamp in your cluster. Authentication / Log-in Currently you can log in Headlamp by using a client-certificate (as you may have configured with e.g. minikube), or a bearer token . Headlamp uses RBAC for checking whether and how users can access resources. This means that the recommended way to log in into Headlamp is to use a Service Account token. Create a Service Account token As an example, you can create a service account for using Headlamp and retrieve its token to authenticate: Create a Service Account: kubectl -n kube-system create serviceaccount headlamp-admin Give admin rights to the account (check the RBAC docs if you want to set more restrictive permissions): kubectl create clusterrolebinding headlamp-admin --serviceaccount=kube-system:headlamp-admin --clusterrole=cluster-admin Get the secret: kubectl -n kube-system get secrets | grep headlamp-admin Get the associated token: kubectl -n kube-system describe secret headlamp-admin-token-XXXXX Once you have the Service Account token, paste it when prompted by Headlamp. Use OIDC For OpenIDConnect, please see the in-cluster installation docs.","title":"Installation / Deployment"},{"location":"installation/_index/#authentication-log-in","text":"Currently you can log in Headlamp by using a client-certificate (as you may have configured with e.g. minikube), or a bearer token . Headlamp uses RBAC for checking whether and how users can access resources. This means that the recommended way to log in into Headlamp is to use a Service Account token.","title":"Authentication / Log-in"},{"location":"installation/_index/#create-a-service-account-token","text":"As an example, you can create a service account for using Headlamp and retrieve its token to authenticate: Create a Service Account: kubectl -n kube-system create serviceaccount headlamp-admin Give admin rights to the account (check the RBAC docs if you want to set more restrictive permissions): kubectl create clusterrolebinding headlamp-admin --serviceaccount=kube-system:headlamp-admin --clusterrole=cluster-admin Get the secret: kubectl -n kube-system get secrets | grep headlamp-admin Get the associated token: kubectl -n kube-system describe secret headlamp-admin-token-XXXXX Once you have the Service Account token, paste it when prompted by Headlamp.","title":"Create a Service Account token"},{"location":"installation/_index/#use-oidc","text":"For OpenIDConnect, please see the in-cluster installation docs.","title":"Use OIDC"},{"location":"installation/base-url/","text":"Normally Headlamp runs at the root of the domain. Hower you can also ask to run it at a base-url like \"/headlamp\" for example. default at the root of the domain: https://headlamp.example.com/ . base-url https://example.com/headlamp/ A warning about multiple apps on the same sub domain Hosting multiple websites (apps) on the same origin can lead to possible conflicts between the apps. Each app is able to access information and make requests of the other. Therefore each app needs to be tested together, trusted , and a compatible Content-Security-Policy should be considered for each of them. If in doubt, host Headlamp on a separate origin (domain or port, don't use the -base-url option). How to use with a base-url Dev mode ./backend/server -dev -base-url /headlamp PUBLIC_URL=\"/headlamp\" make run-frontend Then go to http://localhost:3000/headlamp/ in your browser. Static build mode cd frontend && npm install && npm run build && cd .. ./backend/server -dev -base-url /headlamp -html-static-dir frontend/build Then go to http://localhost:4466/headlamp/ in your browser. Docker mode Append --base-url /headlamp to the docker run command. Note the extra \"-\". Kubernetes You can modify your kubernetes deployment file to add -base-url /headlamp to the containers args. args: - \"-in-cluster\" - \"-plugins-dir=/headlamp/plugins\" - \"-base-url=/headlamp\"","title":"Run Headlamp with a base-url"},{"location":"installation/base-url/#a-warning-about-multiple-apps-on-the-same-sub-domain","text":"Hosting multiple websites (apps) on the same origin can lead to possible conflicts between the apps. Each app is able to access information and make requests of the other. Therefore each app needs to be tested together, trusted , and a compatible Content-Security-Policy should be considered for each of them. If in doubt, host Headlamp on a separate origin (domain or port, don't use the -base-url option).","title":"A warning about multiple apps on the same sub domain"},{"location":"installation/base-url/#how-to-use-with-a-base-url","text":"","title":"How to use with a base-url"},{"location":"installation/base-url/#dev-mode","text":"./backend/server -dev -base-url /headlamp PUBLIC_URL=\"/headlamp\" make run-frontend Then go to http://localhost:3000/headlamp/ in your browser.","title":"Dev mode"},{"location":"installation/base-url/#static-build-mode","text":"cd frontend && npm install && npm run build && cd .. ./backend/server -dev -base-url /headlamp -html-static-dir frontend/build Then go to http://localhost:4466/headlamp/ in your browser.","title":"Static build mode"},{"location":"installation/base-url/#docker-mode","text":"Append --base-url /headlamp to the docker run command. Note the extra \"-\".","title":"Docker mode"},{"location":"installation/base-url/#kubernetes","text":"You can modify your kubernetes deployment file to add -base-url /headlamp to the containers args. args: - \"-in-cluster\" - \"-plugins-dir=/headlamp/plugins\" - \"-base-url=/headlamp\"","title":"Kubernetes"},{"location":"installation/metrics-server/","text":"Headlamp can show information for resources usage if the Metrics Server is installed. If the Metrics Server is not installed, then a related notice is displayed as shown in in the following screenshot: To read more about metrics server check out the metrics-server documentation . Minikube If you are running Minikube, then you can install the Metrics Server by enabling the respective add-on . i.e.: minikube addons enable metrics-server","title":"Kubernetes Metrics Server"},{"location":"installation/metrics-server/#minikube","text":"If you are running Minikube, then you can install the Metrics Server by enabling the respective add-on . i.e.: minikube addons enable metrics-server","title":"Minikube"},{"location":"installation/desktop/","text":"Headlamp can be run as a desktop application, for users who don't want to deploy it in cluster, or those who want to manage unrelated clusters locally. Currently there are desktop apps for Linux , Mac , and Windows . Please check the following guides for the installation in your desired platform. Access using OIDC OIDC has a feature makes more sense when running Headlamp in a cluster as it will allow cluster operators to just give users a URL that they can use for logging in and access Headlamp. However, if you have your kube config set to use OIDC for the authentication (because you already authenticated and produced a kube config with that data), Headlamp will read those settings and try to use them for offering the effortless login to the cluster. Still, the kube config OIDC settings will not provide a OIDC callback URL, so make sure that your OIDC configuration for your cluster include Headlamp's OIDC callback in its redirect URIs. i.e. say you're using Dex for the OIDC connection and you have it already configured in your kube config, then be sure to add the /oidc-callback endpoint with Headlamp's the local address to Dex's staticClient.redirectURIs : http://localhost:6644/oidc-callback .","title":"Desktop App Installation"},{"location":"installation/desktop/#access-using-oidc","text":"OIDC has a feature makes more sense when running Headlamp in a cluster as it will allow cluster operators to just give users a URL that they can use for logging in and access Headlamp. However, if you have your kube config set to use OIDC for the authentication (because you already authenticated and produced a kube config with that data), Headlamp will read those settings and try to use them for offering the effortless login to the cluster. Still, the kube config OIDC settings will not provide a OIDC callback URL, so make sure that your OIDC configuration for your cluster include Headlamp's OIDC callback in its redirect URIs. i.e. say you're using Dex for the OIDC connection and you have it already configured in your kube config, then be sure to add the /oidc-callback endpoint with Headlamp's the local address to Dex's staticClient.redirectURIs : http://localhost:6644/oidc-callback .","title":"Access using OIDC"},{"location":"installation/desktop/_index/","text":"Headlamp can be run as a desktop application, for users who don't want to deploy it in cluster, or those who want to manage unrelated clusters locally. Currently there are desktop apps for Linux , Mac , and Windows . Please check the following guides for the installation in your desired platform. Access using OIDC OIDC has a feature makes more sense when running Headlamp in a cluster as it will allow cluster operators to just give users a URL that they can use for logging in and access Headlamp. However, if you have your kube config set to use OIDC for the authentication (because you already authenticated and produced a kube config with that data), Headlamp will read those settings and try to use them for offering the effortless login to the cluster. Still, the kube config OIDC settings will not provide a OIDC callback URL, so make sure that your OIDC configuration for your cluster include Headlamp's OIDC callback in its redirect URIs. i.e. say you're using Dex for the OIDC connection and you have it already configured in your kube config, then be sure to add the /oidc-callback endpoint with Headlamp's the local address to Dex's staticClient.redirectURIs : http://localhost:6644/oidc-callback .","title":"Desktop App Installation"},{"location":"installation/desktop/_index/#access-using-oidc","text":"OIDC has a feature makes more sense when running Headlamp in a cluster as it will allow cluster operators to just give users a URL that they can use for logging in and access Headlamp. However, if you have your kube config set to use OIDC for the authentication (because you already authenticated and produced a kube config with that data), Headlamp will read those settings and try to use them for offering the effortless login to the cluster. Still, the kube config OIDC settings will not provide a OIDC callback URL, so make sure that your OIDC configuration for your cluster include Headlamp's OIDC callback in its redirect URIs. i.e. say you're using Dex for the OIDC connection and you have it already configured in your kube config, then be sure to add the /oidc-callback endpoint with Headlamp's the local address to Dex's staticClient.redirectURIs : http://localhost:6644/oidc-callback .","title":"Access using OIDC"},{"location":"installation/desktop/headless/","text":"Some users prefer running Headlamp using the desktop app, but directly in their web browser instead of the Electron's environment as this allows them to leverage the browser's functionality such as bookmarks, groups, etc. Running Headlamp in the system's browser can be done by using the --headless CLI option. Assuming the have already downloaded and installed Headlamp on your desktop, you can run it in headless mode as follows: Example: On Linux: flatpak run io.kinvolk.Headlamp --headless (or ./Headlamp.AppImage --headless for AppImage) On MacOS: ./Headlamp --headless On Windows: ./Headlamp.exe --headless","title":"Running in headless mode"},{"location":"installation/desktop/linux-installation/","text":"Currently we ship a Linux desktop application in two formats: Flatpak , and AppImage . Flatpak Flatpak gives an isolated and bundled way of running Headlamp, with decoupled runtime updates (besides other benefits ). You need to make sure that Flatpak is installed in your Linux distro. For installing Headlamp as a Flatpak, follow the instructions in its Flathub page . For running it, just launch it as usually in your Linux desktop, or run: flatpak run io.kinvolk.Headlamp AppImage Headlamp can be used as an AppImage by downloading and running it directly. To download, choose the latest AppImage file from the releases page . You can then run it by doing: ./Headlamp.AppImage","title":"Linux Installation"},{"location":"installation/desktop/linux-installation/#flatpak","text":"Flatpak gives an isolated and bundled way of running Headlamp, with decoupled runtime updates (besides other benefits ). You need to make sure that Flatpak is installed in your Linux distro. For installing Headlamp as a Flatpak, follow the instructions in its Flathub page . For running it, just launch it as usually in your Linux desktop, or run: flatpak run io.kinvolk.Headlamp","title":"Flatpak"},{"location":"installation/desktop/linux-installation/#appimage","text":"Headlamp can be used as an AppImage by downloading and running it directly. To download, choose the latest AppImage file from the releases page . You can then run it by doing: ./Headlamp.AppImage","title":"AppImage"},{"location":"installation/desktop/mac-installation/","text":"For Mac OS we provide a .dmg file, so you need to download it from the releases page and than follow the below steps : Double click the downloaded file to make its content available (name will show up in the Finder sidebar), usually a window opens showing the content as well Drag the application from the DMG window into /Applications to install wait for the copy process to finish. Once the installation process is completed you can find Headlamp as a desktop app in Applications directory.","title":"Mac OS Installation"},{"location":"installation/desktop/win-installation/","text":"For Windows we provide a .setup.exe installer, so you need to download it from the releases page and follow its installation steps (after the installation, you should see Headlamp's icon on your desktop). Important: While running Headlamp, if Windows Defender prompts you about stopping the app because it's from an unknown source, that happens because Headlamp's Windows builds are not yet signed (we're working on it). You can still run the app by choosing \"Run Anyway\".","title":"Windows Installation"},{"location":"installation/in-cluster/","text":"A common use-case for any Kubernetes web UI is to deploy it in-cluster and set up an ingress server for having it available to users. We maintain a simple/vanilla file for setting up a Headlamp deployment and service. Be sure to review it and change anything you need. If you're happy with the options in the this deployment file, and assuming you have a running Kubernetes cluster and your kubeconfig pointing to it, you can run: kubectl apply -f https://raw.githubusercontent.com/kinvolk/headlamp/main/kubernetes-headlamp.yaml Exposing Headlamp with an ingress server With the instructions in the previous section, the Headlamp service should be running, but you still need the ingress server as mentioned. We provide an example sample ingress yaml file for this purpose, but you have to manually replace the URL placeholder with the desired URL (the ingress file also assumes that you have contour and a cert-manager set up, but if you don't then you'll just not have TLS). Assuming your URL is headlamp.mydeployment.io , getting the sample ingress file and changing the URL can quickly be done by: curl -s https://raw.githubusercontent.com/kinvolk/headlamp/main/kubernetes-headlamp-ingress-sample.yaml | sed -e s/__URL__/headlamp.mydeployment.io/ > headlamp-ingress.yaml and with that, you'll have a configured ingress file, so verify it and apply it: kubectl apply -f ./headlamp-ingress.yaml Exposing Headlamp with port-forwarding If you want to quickly access Headlamp (after having its service running) and don't want to set up an ingress for it, you can run use port-forwarding as follows: kubectl port-forward -n kube-system service/headlamp 8080:80 and then you can access localhost:8080 in your browser. Accessing Headlamp Once Headlamp is up and running, be sure to enable access to it either by creating a service account or by setting up OIDC .","title":"In-cluster Deployment"},{"location":"installation/in-cluster/#exposing-headlamp-with-an-ingress-server","text":"With the instructions in the previous section, the Headlamp service should be running, but you still need the ingress server as mentioned. We provide an example sample ingress yaml file for this purpose, but you have to manually replace the URL placeholder with the desired URL (the ingress file also assumes that you have contour and a cert-manager set up, but if you don't then you'll just not have TLS). Assuming your URL is headlamp.mydeployment.io , getting the sample ingress file and changing the URL can quickly be done by: curl -s https://raw.githubusercontent.com/kinvolk/headlamp/main/kubernetes-headlamp-ingress-sample.yaml | sed -e s/__URL__/headlamp.mydeployment.io/ > headlamp-ingress.yaml and with that, you'll have a configured ingress file, so verify it and apply it: kubectl apply -f ./headlamp-ingress.yaml","title":"Exposing Headlamp with an ingress server"},{"location":"installation/in-cluster/#exposing-headlamp-with-port-forwarding","text":"If you want to quickly access Headlamp (after having its service running) and don't want to set up an ingress for it, you can run use port-forwarding as follows: kubectl port-forward -n kube-system service/headlamp 8080:80 and then you can access localhost:8080 in your browser.","title":"Exposing Headlamp with port-forwarding"},{"location":"installation/in-cluster/#accessing-headlamp","text":"Once Headlamp is up and running, be sure to enable access to it either by creating a service account or by setting up OIDC .","title":"Accessing Headlamp"},{"location":"installation/in-cluster/_index/","text":"A common use-case for any Kubernetes web UI is to deploy it in-cluster and set up an ingress server for having it available to users. We maintain a simple/vanilla file for setting up a Headlamp deployment and service. Be sure to review it and change anything you need. If you're happy with the options in the this deployment file, and assuming you have a running Kubernetes cluster and your kubeconfig pointing to it, you can run: kubectl apply -f https://raw.githubusercontent.com/kinvolk/headlamp/main/kubernetes-headlamp.yaml Exposing Headlamp with an ingress server With the instructions in the previous section, the Headlamp service should be running, but you still need the ingress server as mentioned. We provide an example sample ingress yaml file for this purpose, but you have to manually replace the URL placeholder with the desired URL (the ingress file also assumes that you have contour and a cert-manager set up, but if you don't then you'll just not have TLS). Assuming your URL is headlamp.mydeployment.io , getting the sample ingress file and changing the URL can quickly be done by: curl -s https://raw.githubusercontent.com/kinvolk/headlamp/main/kubernetes-headlamp-ingress-sample.yaml | sed -e s/__URL__/headlamp.mydeployment.io/ > headlamp-ingress.yaml and with that, you'll have a configured ingress file, so verify it and apply it: kubectl apply -f ./headlamp-ingress.yaml Exposing Headlamp with port-forwarding If you want to quickly access Headlamp (after having its service running) and don't want to set up an ingress for it, you can run use port-forwarding as follows: kubectl port-forward -n kube-system service/headlamp 8080:80 and then you can access localhost:8080 in your browser. Accessing Headlamp Once Headlamp is up and running, be sure to enable access to it either by creating a service account or by setting up OIDC .","title":"In-cluster Deployment"},{"location":"installation/in-cluster/_index/#exposing-headlamp-with-an-ingress-server","text":"With the instructions in the previous section, the Headlamp service should be running, but you still need the ingress server as mentioned. We provide an example sample ingress yaml file for this purpose, but you have to manually replace the URL placeholder with the desired URL (the ingress file also assumes that you have contour and a cert-manager set up, but if you don't then you'll just not have TLS). Assuming your URL is headlamp.mydeployment.io , getting the sample ingress file and changing the URL can quickly be done by: curl -s https://raw.githubusercontent.com/kinvolk/headlamp/main/kubernetes-headlamp-ingress-sample.yaml | sed -e s/__URL__/headlamp.mydeployment.io/ > headlamp-ingress.yaml and with that, you'll have a configured ingress file, so verify it and apply it: kubectl apply -f ./headlamp-ingress.yaml","title":"Exposing Headlamp with an ingress server"},{"location":"installation/in-cluster/_index/#exposing-headlamp-with-port-forwarding","text":"If you want to quickly access Headlamp (after having its service running) and don't want to set up an ingress for it, you can run use port-forwarding as follows: kubectl port-forward -n kube-system service/headlamp 8080:80 and then you can access localhost:8080 in your browser.","title":"Exposing Headlamp with port-forwarding"},{"location":"installation/in-cluster/_index/#accessing-headlamp","text":"Once Headlamp is up and running, be sure to enable access to it either by creating a service account or by setting up OIDC .","title":"Accessing Headlamp"},{"location":"installation/in-cluster/oidc/","text":"Headlamp supports OIDC for cluster users to effortlessly log in using a \"Sign in\" button. For OIDC to be used, Headlamp needs to know how to configure it, so you have to provide the different OIDC-related arguments to Headlamp from your OIDC provider. Those are: the client ID: -oidc-client-id the client secret: -oidc-client-secret the issuer URL: -oidc-idp-issuer-url (optionally) the OpenId scopes: -oidc-scopes and you have to tell the OIDC provider about the callback URL, which in Headlamp it is your URL + the /oidc-callback path, e.g.: https://YOUR_URL/oidc-callback . Scopes Besides the mandatory openid scope, Headlamp also requests the optional profile and email scopes . Scopes can be overridden by using the -oidc-scopes option. Remember to include the default ones if you need them when using that option. For example, if you need to keep the default scopes and add Github's repo , then add them all to the option: -oidc-scopes=profile,email,repo Note: Before Headlamp 0.3.0, a scope groups was also included, as it's used by Dex and other services, but since it's not part of the default spec, it was removed in the mentioned version. Example: OIDC with Dex If you are using Dex and want to configure Headlamp to use it for OIDC, then you have to: Add the callback URL (e.g. https://YOUR_URL/oidc-callback ) to Dex's staticClient.redirectURIs Set -oidc-client-id as Dex's staticClient.id Set -oidc-client-secret as Dex's staticClient.secret Set -oidc-idp-issuer-url as Dex's URL (same as in --oidc-issuer-url in the Kubernetes APIServer) Set -oidc-scopes if needed, e.g. -oidc-scopes=profile,email,groups","title":"Accessing using OpenID Connect"},{"location":"installation/in-cluster/oidc/#scopes","text":"Besides the mandatory openid scope, Headlamp also requests the optional profile and email scopes . Scopes can be overridden by using the -oidc-scopes option. Remember to include the default ones if you need them when using that option. For example, if you need to keep the default scopes and add Github's repo , then add them all to the option: -oidc-scopes=profile,email,repo Note: Before Headlamp 0.3.0, a scope groups was also included, as it's used by Dex and other services, but since it's not part of the default spec, it was removed in the mentioned version.","title":"Scopes"},{"location":"installation/in-cluster/oidc/#example-oidc-with-dex","text":"If you are using Dex and want to configure Headlamp to use it for OIDC, then you have to: Add the callback URL (e.g. https://YOUR_URL/oidc-callback ) to Dex's staticClient.redirectURIs Set -oidc-client-id as Dex's staticClient.id Set -oidc-client-secret as Dex's staticClient.secret Set -oidc-idp-issuer-url as Dex's URL (same as in --oidc-issuer-url in the Kubernetes APIServer) Set -oidc-scopes if needed, e.g. -oidc-scopes=profile,email,groups","title":"Example: OIDC with Dex"}]}