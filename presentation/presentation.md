# Consolidate Headlamp plugins development story 



## Creating a new plugin

Create react app already comes with a template system, and has 
[documentation on Custom Templates](https://create-react-app.dev/docs/custom-templates/)

We could create a template called `cra-headlamp`.

```bash
npx create-react-app headlamp-myfancy --template headlamp
```

---

We have a [Custom templates](https://create-react-app.dev/docs/custom-templates/)
in cra-template-headlamp. To test before it's published do:

```bash
npx create-react-app headlamp-myfancy --template file:frontend/presentation/cra-template-headlamp
```


## Making things comfy

Guiding development with rails to be comfy, and consistent with a Create React App template.

- Headlamp dependencies already setup
- Quickstart README
- testing with jest
- storybooks
- eslint/prettier/TypeScript config


### code reload, component lifecycle

During development having automatic code reloading is required for a good developer experience.

A component lifecycle is needed for reloading. Init, quit, change based on state and property changes.
React components have a life cycle, built in, so let's use that!



## Enabling plugins and configuration

available VS enabled

With several plugins available, only enable some of them.

- configure installed
- configure enabled
- plugin options


## Working out of the plugin tree.

### npm link

`yarn link`/`npm link` can be used to "link" modules allowing for easy development.


---


Inside the plugin during development.
```bash
npm link
```

Inside the plugin folder.

```bash
npm link "headlamp-greenify"
```


### Dynamic import

Dynamic imports needs a folder of plugins where it will look at, at build time.

See [Dynamic expressions in import()](https://webpack.js.org/api/module-methods/#dynamic-expressions-in-import)



## Minimal file

It can do reloading if you create a minimal file, which does the import.
Then if you 'link' the module it will work.

```js
// plugins-enabled/greenify.js
import { initialize } from 'headlamp-greenify';
export { initialize }
```

This lets you do development, but be able to keep the plugin "out of tree".



## loadEnabledPlugins

Here is some code which does the dynamic imports. 
Note you have to specify a list of enabled plugins, and that it looks in a folder of plugins at build time.

```js
async function loadEnabledPlugins() {
  // const enabledPlugins = await fetch('/plugins/enabled')
  const enabledPlugins = ['greenify'];

  for (const plugin of enabledPlugins) {
    const aPlugin = await import(`./plugins-enabled/${plugin}`);
    if ("initialize" in aPlugin) {
      window.plugins[plugin] = aPlugin;
    }
  }
}
```



## Failed experiments

Note, I tried some failed experiements:

- using the node_modules folder crashes webpack, because it then tries to load everything in there.
- Symlinking only the module from node_modules does not work, because it does other random things.


Having a "plugins-enabled" folder which is generated by the server could be an option.



## Documentation



## Runnable playground with Storybook

Integrated into the developer documentation


---

TODO: write a note in plugins docs about how to run it.


## Detailed API reference

... with typedoc

Integrated into the developer documentation at https://kinvolk.io/docs/headlamp/latest/development/api/

docs/



### Discoverable examples

- plugins/ folder at top level of Headlamp repo
- npm (labeled headlamp and headlamp-plugin)
- github (labeled headlamp and headlamp-plugin)
- documentation, generated from the repo/github/npm (official plugins, thirdparty ones)

---



## Packing for Web browser, or packing as a npm package.

---

TODO: We use the watch command from the previous way, but the build from the new way.
TODO: list npm run xbuild watch/etc commands.
TODO: main.js is the for web one, and index.js is the package one.




server in dev mode, can automatically reload plugins that are npm installed
	looks for "headlampl-X"
		returns in plugins enabled list
		makes a "plugins-enabled/headlamp-X/index.ts" file 

	This way npm install the package, and npm link it and it is used in the app




## Weird imports, and Headlamp API packages

TODO: how to get rid of these weird imports at the top of our plugins?

```javascript
import { Plugin } from '@kinvolk/headlamp-plugin/types/plugin/index.d';
import Registry from '@kinvolk/headlamp-plugin/types/plugin/registry.d';

const pluginLib = window.pluginLib;
const React = window.pluginLib.React;
const K8s = pluginLib.K8s.ResourceClasses;
const { Typography } = pluginLib.MuiCore;
```

---

We don't have our APIs separated from the Headlamp app yet.


### Headlamp APIs


TODO: extract lib/k8s, and some of components?

- @kinvolk/headlamp/lib/k8s (`packages/headlamp-lib-k8s`)
- @kinvolk/headlamp/components/common `packages/headlamp-components`

TODO: but how do web-packaged-and-loaded packages use these components? peer-dependencies?


## Basic Simple Theme

- Logo, description, and URL.
- Colors, fonts, and more.


```javascript
import { create } from '@kinvolk/headlamp/theming';
// import logoUrl from '../../docs/headlamp_light.svg';

export default create({
  base: 'light',
  brandTitle: 'Headlamp Kubernetes Web UI dashboard',
  brandUrl: 'https://kinvolk.io/docs/headlamp/latest/development/',
  // brandImage: logoUrl,
  brandImage: 'https://example.com/logo.png',
});
```

--- 

TODO: How to theme it? As a plugin.
TODO: have a simple way to do the basics is useful, rather than a full blown MUI theme?


## Plugin tests

TODO: set up a test in an example plugin.
TODO: should this include a component story?

